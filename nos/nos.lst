mads 2.1.0
Source: nos.s
     1 				        
     2 				        ;; Compile with MADS
     3
     4 				        ;; Authors: Thomas Cherryhomes
     5 				        ;;   <thom.cherryhomes@gmail.com>
     6
     7 				        ;; Michael Sternberg
     8 				        ;;   <mhsternberg@gmail.com>
     9
    10
    11 				        ;; Optimizations being done by djaybee!
    12 				        ;; Thank you so much!
    13
    14
    15 = 000A			DOSVEC  =   $0A         ; DOSVEC
    16 = 000C			DOSINI  =   $0C         ; DOSINI
    17
    18 				        ;; CURRENT IOCB IN ZERO PAGE
    19 = 0020			ZIOCB   =   $20         ; ZP IOCB
    20 = 0020			ZICHID  =   ZIOCB       ; ID
    21 = 0021			ZICDNO  =   ZIOCB+1     ; UNIT #
    22 = 0022			ZICCOM  =   ZIOCB+2     ; COMMAND
    23 = 0023			ZICSTA  =   ZIOCB+3     ; STATUS
    24 = 0024			ZICBAL  =   ZIOCB+4     ; BUF ADR LOW
    25 = 0025			ZICBAH  =   ZIOCB+5     ; BUF ADR HIGH
    26 = 0026			ZICPTL  =   ZIOCB+6     ; PUT ADDR L
    27 = 0027			ZICPTH  =   ZIOCB+7     ; PUT ADDR H
    28 = 0028			ZICBLL  =   ZIOCB+8     ; BUF LEN LOW
    29 = 0029			ZICBLH  =   ZIOCB+9     ; BUF LEN HIGH
    30 = 002A			ZICAX1  =   ZIOCB+10    ; AUX 1
    31 = 002B			ZICAX2  =   ZIOCB+11    ; AUX 2
    32 = 002C			ZICAX3  =   ZIOCB+12    ; AUX 3
    33 = 002D			ZICAX4  =   ZIOCB+13    ; AUX 4
    34 = 002E			ZICAX5  =   ZIOCB+14    ; AUX 5
    35 = 002F			ZICAX6  =   ZIOCB+15    ; AUX 6
    36
    37 = 0052			LMARGN  =   $52         ; Left margin
    38 = 00D4			FR0     =   $D4         ; Floating Point register 0 (used during Hex->ASCII conversion)
    39 = 00F2			CIX     =   $F2         ; Inbuff cursor
    40 = 00F3			INBUFF  =   $F3         ; Ptr to input buffer ($0580)
    41 = 0040			MAX_APPKEY_LEN = $40    ; Used with appkey files
    42
    43 				;---------------------------------------
    44 				; INTERRUPT VECTORS
    45 				; AND OTHER PAGE 2 VARS
    46 				;---------------------------------------
    47
    48 = 0202			VPRCED  =   $0202       ; PROCEED VCTR
    49 = 02C6			COLOR2  =   $02C6       ; MODEF BKG C
    50 = 02E0			RUNAD   =   $02E0       ; RUN ADDRESS
    51 = 02E2			INITAD  =   $02E2       ; INIT ADDRESS
    52 = 02E7			MEMLO   =   $02E7       ; MEM LO
    53 = 02EA			DVSTAT  =   $02EA       ; 4 BYTE STATS
    54
    55 				;---------------------------------------
    56 				; PAGE 3
    57 				; DEVICE CONTROL BLOCK (DCB)
    58 				;---------------------------------------
    59
    60 = 0300			DCB     =   $0300       ; BASE
    61 = 0300			DDEVIC  =   DCB         ; DEVICE #
    62 = 0301			DUNIT   =   DCB+1       ; UNIT #
    63 = 0302			DCOMND  =   DCB+2       ; COMMAND
    64 = 0303			DSTATS  =   DCB+3       ; STATUS/DIR
    65 = 0304			DBUFL   =   DCB+4       ; BUF ADR L
    66 = 0305			DBUFH   =   DCB+5       ; BUF ADR H
    67 = 0306			DTIMLO  =   DCB+6       ; TIMEOUT (S)
    68 = 0307			DRSVD   =   DCB+7       ; NOT USED
    69 = 0308			DBYTL   =   DCB+8       ; BUF LEN L
    70 = 0309			DBYTH   =   DCB+9       ; BUF LEN H
    71 = 030A			DAUXL   =   DCB+10      ; AUX BYTE L
    72 = 030B			DAUXH   =   DCB+11      ; AUX BYTE H
    73
    74 = 031A			HATABS  =   $031A       ; HANDLER TBL
    75
    76 				;---------------------------------------
    77 				; IOCB'S * 8
    78 				;---------------------------------------
    79
    80 = 0340			IOCB    =   $0340       ; IOCB BASE
    81 = 0340			ICHID   =   IOCB        ; ID
    82 = 0341			ICDNO   =   IOCB+1      ; UNIT #
    83 = 0342			ICCOM   =   IOCB+2      ; COMMAND
    84 = 0343			ICSTA   =   IOCB+3      ; STATUS
    85 = 0344			ICBAL   =   IOCB+4      ; BUF ADR LOW
    86 = 0345			ICBAH   =   IOCB+5      ; BUF ADR HIGH
    87 = 0346			ICPTL   =   IOCB+6      ; PUT ADDR L
    88 = 0347			ICPTH   =   IOCB+7      ; PUT ADDR H
    89 = 0348			ICBLL   =   IOCB+8      ; BUF LEN LOW
    90 = 0349			ICBLH   =   IOCB+9      ; BUF LEN HIGH
    91 = 034A			ICAX1   =   IOCB+10     ; AUX 1
    92 = 034B			ICAX2   =   IOCB+11     ; AUX 2
    93 = 034C			ICAX3   =   IOCB+12     ; AUX 3
    94 = 034D			ICAX4   =   IOCB+13     ; AUX 4
    95 = 034E			ICAX5   =   IOCB+14     ; AUX 5
    96 = 034F			ICAX6   =   IOCB+15     ; AUX 6
    97
    98 = 0054			ROWCRS  =   $0054
    99 = 02BB			SCRFLG  =   $02BB       ; Scroll flag
   100 = 02FC			CH      =   $02FC       ; Hardware code for last key pressed
   101 = 02F2			CH1     =   $02F2       ; Prior keyboard character code
   102 				;LNBUF   =   $0582       ; Line Buffer (128 bytes)
   103 = 1880			LNBUF   =   $1880       ; Line Buffer (128 bytes)
   104
   105 				;---------------------------------------
   106 				; HARDWARE REGISTERS
   107 				;---------------------------------------
   108
   109 = D01F			CONSOL  =   $D01F       ; Console switches
   110 = D301			PORTB   =   $D301       ; On XL/XE, used to enable/disable BASIC
   111 = D302			PACTL   =   $D302       ; PIA CTRL A
   112
   113 				;---------------------------------------
   114 				; MATH PACK VECTORS
   115 				;---------------------------------------
   116 = D8E6			FASC    =   $D8E6       ; Floating point to ASCII
   117 = D9AA			IFP     =   $D9AA       ; Integer to floating point
   118
   119 				;---------------------------------------
   120 				; OS ROM VECTORS
   121 				;---------------------------------------
   122
   123 = E456			CIOV    =   $E456       ; CIO ENTRY
   124 = E459			SIOV    =   $E459       ; SIO ENTRY
   125 = E474			WARMSV  =   $E474       ; Warmstart entry point
   126 = E477			COLDSV  =   $E477       ; Coldstart entry point
   127
   128 				;---------------------------------------
   129 				; CONSTANTS
   130 				;---------------------------------------
   131
   132 = 0005			GETREC  =   $05         ; CIO CMD TO GET RECORD
   133 = 0009			PUTREC  =   $09         ; CIO CMD TO PUT RECORD
   134 = 000B			PUTCHR  =   $0B         ; CIO CMD TO PUT CHAR
   135
   136 = 0071			DEVIDN  =   $71         ; SIO DEVID
   137 = 0040			DSREAD  =   $40         ; FUJI->ATARI
   138 = 0080			DSWRIT  =   $80         ; ATARI->FUJI
   139 = 0004			MAXDEV  =   4           ; # OF N: DEVS
   140 = 0088			EOF     =   $88         ; ERROR 136
   141
   142 = 009B			EOL     =   $9B         ; EOL CHAR
   143 = 000D			CR      =   $0D         ; Carrige Return
   144 = 000A			LF      =   $0A         ; Linefeed
   145
   146 = 0003			OPTION  =   $03
   147 = 001C			ESC_KEY =   $1C         ; Hardware code for ESC
   148 = 0021			SPC_KEY =   $21         ; Hardware code for SPACE
   149
   150 = 0004			OINPUT  =   $04         ; CIO/SIO direction
   151 = 0008			OOUTPUT =   $08         ; CIO/SIO direction
   152 = 00F0			BOGUS   =   $F0         ; Bogus FujiNet SIO command byte
   153
   154 				; FujiNet SIO command bytes.
   155 = 0001			CMD_DRIVE_CHG       = $01
   156 = 002C			CMD_CD              = $2C
   157 				;CMD_COPY            = $A1
   158 = 0002			CMD_DIR             = $02
   159 = 0021			CMD_DEL             = $21
   160 = 0028			CMD_LOAD            = $28
   161 				;CMD_LOCK            = $23
   162 = 00FD			CMD_LOGIN           = $FD
   163 = 00F0			CMD_LPR             = BOGUS
   164 = 002A			CMD_MKDIR           = $2A
   165 = 0030			CMD_NPWD            = $30
   166 = 0054			CMD_NTRANS          = 'T'
   167 = 00FE			CMD_PASSWD          = $FE
   168 = 0020			CMD_RENAME          = $20
   169 = 002B			CMD_RMDIR           = $2B
   170 = 00F0			CMD_SUBMIT          = BOGUS
   171 = 00F0			CMD_TYPE            = BOGUS
   172 				;CMD_UNLOCK          = $24
   173 = 00F0			CMD_CAR             = BOGUS
   174 = 00F0			CMD_CLS             = BOGUS
   175 = 00F0			CMD_COLD            = BOGUS
   176 = 00F0			CMD_HELP            = BOGUS
   177 = 00F0			CMD_NOBASIC         = BOGUS
   178 = 00F0			CMD_NOSCREEN        = BOGUS
   179 = 00F0			CMD_PRINT           = BOGUS
   180 = 00F0			CMD_REENTER         = BOGUS
   181 = 00F0			CMD_REM             = BOGUS
   182 = 00F0			CMD_RUN             = BOGUS
   183 = 00F0			CMD_SCREEN          = BOGUS
   184 = 00F0			CMD_WARM            = BOGUS
   185 = 00F0			CMD_XEP             = BOGUS
   186 = 00F0			CMD_AUTORUN         = BOGUS
   187
   188 				;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   189
   190 				        .MACRO DCBC
   191 				        .LOCAL
   192 				        LDY     #$0C
   193 				?DCBL   LDA     %%1,Y
   194 				        STA     DCB,Y
   195 				        DEY
   196 				        BPL     ?DCBL
   197 				        .ENDL
   198 				        .ENDM
   199
   200 				; ATR Header
   201 					    ORG	    $06f0
   202 				        OPT     h-
   203 06F0 96 02 80 16 80		    DTA	    $96,$02,$80,$16,$80
   204 06F5 00 00 00 00 00 00 + :11     DTA	    $00
   205
   206 				;;; Initialization ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   207
   208 0700 00			HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   209 0701 22			        .BYTE   [BOOTEND-HDR]/128   ; BRCNT: Number of consecutive sectors to read
   210 0702 00 07		        .WORD   HDR                 ; BLDADR: Boot sector load address ($700).
   211 0704 C0 E4		        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   212
   213 0706 4C 09 07			    JMP	    START
   214
   215 0709 A5 0C		START:  LDA     DOSINI
   216 070B 8D 27 07		        STA     RESET+1
   217 070E A5 0D		        LDA     DOSINI+1
   218 0710 8D 28 07		        STA     RESET+2
   219
   220 0713 A9 26		        LDA     #<RESET
   221 0715 85 0C		        STA     DOSINI
   222 0717 A9 07		        LDA     #>RESET
   223 0719 85 0D		        STA     DOSINI+1
   224 071B A9 DC		        LDA     #<DOS       ; Point to DOS & CP below
   225 071D 85 0A		        STA     DOSVEC
   226 071F A9 0A		        LDA     #>DOS
   227 0721 85 0B		        STA     DOSVEC+1
   228
   229 0723 4C 39 07		        JMP     ALTMEML     ; Alter MEMLO
   230
   231 0726 20 FF FF		RESET:  JSR     $FFFF       ; Jump to extant DOSINI
   232
   233 0729 A9 4E		        LDA     #'N'
   234 072B 8D 00 18		        STA     RBUF
   235 072E 20 44 07		        JSR     IHTBS       ; Insert into HATABS
   236
   237 0731 A9 44		        LDA     #'D'
   238 0733 8D 00 18		        STA     RBUF
   239 0736 20 44 07		        JSR     IHTBS       ; Clone N: as D: for compatibility
   240
   241 				;---------------------------------------
   242 				;  Alter MEMLO
   243 				;---------------------------------------
   244 0739			ALTMEML:
   245 0739 A9 00		        LDA     #<PGEND
   246 073B 8D E7 02		        STA     MEMLO
   247 073E A9 19		        LDA     #>PGEND
   248 0740 8D E8 02		        STA     MEMLO+1
   249
   250 				        ;; Back to DOS
   251
   252 0743 60			        RTS
   253
   254 				;---------------------------------------
   255 				; Insert entry into HATABS
   256 				;---------------------------------------
   257
   258 0744			IHTBS:
   259 0744 A0 00		        LDY     #$00
   260 0746 B9 1A 03		IH1     LDA     HATABS,Y
   261 0749 F0 0C		        BEQ     HFND
   262 074B CD 00 18		        CMP     RBUF        ; RBUF contains 'N' or 'D'
   263 074E F0 07		        BEQ     HFND
   264 0750 C8			        INY
   265 0751 C8			        INY
   266 0752 C8			        INY
   267 0753 C0 21		        CPY     #11*3
   268 0755 90 EF		        BCC     IH1
   269
   270 				        ;; Found a slot
   271
   272 0757			HFND:
   273 0757 AD 00 18		        LDA     RBUF        ; RBUF contains 'N' or 'D'
   274 075A AA			        TAX
   275 075B 99 1A 03		        STA     HATABS,Y
   276 075E A9 36		        LDA     #<CIOHND
   277 0760 99 1B 03		        STA     HATABS+1,Y
   278 0763 A9 17		        LDA     #>CIOHND
   279 0765 99 1C 03		        STA     HATABS+2,Y
   280
   281 0768 E0 44		        CPX     #'D'
   282 076A F0 01		        BEQ     HATABS_CONT
   283 076C 60			        RTS
   284
   285 076D			HATABS_CONT:
   286 				        ;; And we're done with HATABS
   287
   288 				        ;; Query FUJINET
   289
   290 076D 20 24 09		        JSR     STPOLL
   291
   292 				        ;; Output Ready/Error
   293
   294 0770			OBANR:
   295 0770 A2 00		        LDX     #$00        ; IOCB #0
   296 0772 A9 09		        LDA     #PUTREC
   297 0774 9D 42 03		        STA     ICCOM,X
   298 0777 A9 28		        LDA     #$28        ; 40 CHARS Max
   299 0779 9D 48 03		        STA     ICBLL,X
   300 077C 8A			        TXA
   301 077D 9D 49 03		        STA     ICBLH,X
   302 0780 AD 03 03		        LDA     DSTATS      ; Check DSTATS
   303 0783 10 06		        BPL     OBRDY       ; < 128 = Ready
   304
   305 				        ;; Status returned error.
   306
   307 0785			OBERR:
   308 0785 A9 5C		        LDA     #<BERROR
   309 0787 A0 17		        LDY     #>BERROR
   310 0789 50 04		        BVC     OBCIO
   311
   312 				        ;; Status returned ready.
   313
   314 078B			OBRDY:
   315 078B A9 42		        LDA     #<BREADY
   316 078D A0 17		        LDY     #>BREADY
   317
   318 078F			OBCIO:
   319 078F 9D 44 03		        STA     ICBAL,X
   320 0792 98			        TYA
   321 0793 9D 45 03		        STA     ICBAH,X
   322
   323 0796 20 56 E4		        JSR     CIOV
   324
   325 				        ;; Vector in proceed interrupt
   326
   327 0799			SPRCED:
   328 0799 A9 6B		        LDA     #<PRCVEC
   329 079B 8D 02 02		        STA     VPRCED
   330 079E A9 0A		        LDA     #>PRCVEC
   331 07A0 8D 03 02		        STA     VPRCED+1
   332
   333 				        ;; And we are done, back to DOS.
   334 07A3 18			        CLC
   335 07A4 60			        RTS
   336
   337 				;;; End Initialization Code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   338
   339 				; Copy command's template DCB struct to OS's DCB struct (12 bytes)
   340 07A5			DOSIOV:
   341 07A5 8D AE 07		        STA     DODCBL+1
   342 07A8 8C AF 07		        STY     DODCBL+2
   343 07AB A0 0C		        LDY     #$0C
   344 07AD B9 FF FF		DODCBL  LDA     $FFFF,Y
   345 07B0 99 00 03		        STA     DCB,Y
   346 07B3 88			        DEY
   347 07B4 10 F7		        BPL     DODCBL
   348
   349 07B6			SIOVDST:
   350 07B6 20 59 E4		        JSR     SIOV
   351 07B9 AC 03 03		        LDY     DSTATS
   352 07BC 98			        TYA
   353 07BD 60			        RTS
   354
   355
   356 				;---------------------------------------
   357 				; CIO OPEN
   358 				;---------------------------------------
   359
   360 07BE			OPEN:
   361 				        ;; Prepare DCB
   362
   363 07BE 20 5C 0A		        JSR     GDIDX       ; Get Device ID in X (0-3)
   364 07C1 A5 21		        LDA     ZICDNO      ; IOCB UNIT # (1-4)
   365 07C3 8D 01 08		        STA     OPNDCB+1    ; Store in DUNIT
   366 07C6 A5 24		        LDA     ZICBAL      ; Get filename buffer
   367 07C8 8D 04 08		        STA     OPNDCB+4    ; stuff in DBUF
   368 07CB A5 25		        LDA     ZICBAH      ; ...
   369 07CD 8D 05 08		        STA     OPNDCB+5    ; ...
   370 07D0 A5 2A		        LDA     ZICAX1      ; Get desired AUX1/AUX2
   371 07D2 8D 0A 08		        STA     OPNDCB+10   ; Save them, and store in DAUX1/DAUX2
   372 07D5 A5 2B		        LDA     ZICAX2      ; ...
   373 07D7 8D 0B 08		        STA     OPNDCB+11   ; ...
   374
   375 				        ;;  Copy DCB template to DCB
   376
   377 07DA A9 00		        LDA     #<OPNDCB
   378 07DC A0 08		        LDY     #>OPNDCB
   379
   380 				        ;;  Send to #FujiNet
   381
   382 07DE 20 A5 07		        JSR     DOSIOV
   383
   384 				        ;; Return DSTATS, unless 144, then get extended error
   385
   386 07E1			OPCERR:
   387 07E1 C0 90		        CPY     #$90        ; ERR 144?
   388 07E3 D0 06		        BNE     OPDONE      ; NOPE. RETURN DSTATS
   389
   390 				        ;; 144 - get extended error
   391
   392 07E5 20 24 09		        JSR     STPOLL      ; POLL FOR STATUS
   393 07E8 AC ED 02		        LDY     DVSTAT+3
   394
   395 				       ; RESET BUFFER LENGTH + OFFSET
   396
   397 07EB			OPDONE:
   398 07EB A9 01		        LDA     #$01
   399 07ED 8D 7A 17		        STA     TRIP
   400 07F0 20 5C 0A		        JSR     GDIDX
   401 07F3 A9 00		        LDA     #$00
   402 07F5 9D 7B 17		        STA     RLEN,X
   403 07F8 9D 83 17		        STA     TOFF,X
   404 07FB 9D 7F 17		        STA     ROFF,X
   405 07FE 98			        TYA
   406 07FF 60			        RTS                ; AY = ERROR
   407
   408 0800			OPNDCB:
   409 0800 71			        .BYTE   DEVIDN  ; DDEVIC
   410 0801 FF			        .BYTE   $FF     ; DUNIT
   411 0802 4F			        .BYTE   'O'     ; DCOMND
   412 0803 80			        .BYTE   $80     ; DSTATS
   413 0804 FF			        .BYTE   $FF     ; DBUFL
   414 0805 FF			        .BYTE   $FF     ; DBUFH
   415 0806 0F			        .BYTE   $0F     ; DTIMLO
   416 0807 00			        .BYTE   $00     ; DRESVD
   417 0808 00			        .BYTE   $00     ; DBYTL
   418 0809 01			        .BYTE   $01     ; DBYTH
   419 080A FF			        .BYTE   $FF     ; DAUX1
   420 080B FF			        .BYTE   $FF     ; DAUX2
   421
   422 				; End CIO OPEN
   423 				;---------------------------------------
   424
   425 				;---------------------------------------
   426 				; CIO CLOSE 
   427 				;---------------------------------------
   428
   429 080C			CLOSE:
   430 080C 20 53 0A		        JSR     DIPRCD      ; Disable Interrupts
   431 080F 20 5C 0A		        JSR     GDIDX
   432 0812 20 AF 08		        JSR     PFLUSH      ; Do a Put Flush if needed.
   433
   434 0815 A5 21		        LDA     ZICDNO      ; IOCB Unit #
   435 0817 8D 22 08		        STA     CLODCB+1    ; to DCB...
   436
   437 081A A9 21		        LDA     #<CLODCB
   438 081C A0 08		        LDY     #>CLODCB
   439
   440 081E 4C A5 07		        JMP     DOSIOV
   441
   442 0821 71			CLODCB .BYTE    DEVIDN      ; DDEVIC
   443 0822 FF			       .BYTE    $FF         ; DUNIT
   444 0823 43			       .BYTE    'C'         ; DCOMND
   445 0824 00			       .BYTE    $00         ; DSTATS
   446 0825 00			       .BYTE    $00         ; DBUFL
   447 0826 00			       .BYTE    $00         ; DBUFH
   448 0827 0F			       .BYTE    $0F         ; DTIMLO
   449 0828 00			       .BYTE    $00         ; DRESVD
   450 0829 00			       .BYTE    $00         ; DBYTL
   451 082A 00			       .BYTE    $00         ; DBYTH
   452 082B 00			       .BYTE    $00         ; DAUX1
   453 082C 00			       .BYTE    $00         ; DAUX2
   454
   455 				; End CIO CLOSE
   456 				;---------------------------------------
   457
   458 				;---------------------------------------
   459 				; CIO GET
   460 				;---------------------------------------
   461
   462 082D 20 5C 0A		GET:    JSR     GDIDX       ; IOCB UNIT #-1 into X
   463 0830 BD 7B 17		        LDA     RLEN,X      ; Get # of RX chars waiting
   464 0833 D0 2B		        BNE     GETDISC     ; LEN > 0?
   465
   466 				        ;; If RX buffer is empty, get # of chars waiting...
   467
   468 0835 20 24 09		        JSR     STPOLL      ; Status Poll
   469 0838 20 5C 0A		        JSR     GDIDX       ; IOCB UNIT -1 into X (because Poll trashes X)
   470 083B AD EA 02		        LDA     DVSTAT      ; # of bytes waiting (0-127)
   471 083E 9D 7B 17		        STA     RLEN,X      ; Store in RX Len
   472 0841 F0 22		        BEQ     RETEOF
   473
   474 0843 A5 21		GETDO:  LDA     ZICDNO      ; Get IOCB UNIT #
   475 0845 8D 83 08		        STA     GETDCB+1    ; Store into DUNIT
   476 0848 AD EA 02		        LDA     DVSTAT      ; # of bytes waiting
   477 084B 8D 8A 08		        STA     GETDCB+8    ; Store into DBYT...
   478 084E 8D 8C 08		        STA     GETDCB+10   ; and DAUX1...
   479
   480 0851 A9 82		        LDA     #<GETDCB
   481 0853 A0 08		        LDY     #>GETDCB
   482
   483 0855 20 A5 07		        JSR     DOSIOV
   484
   485 				        ;; Clear the Receive buffer offset.
   486
   487 0858 20 5C 0A		        JSR     GDIDX       ; IOCB UNIT #-1 into X
   488 085B A9 00		        LDA     #$00
   489 085D 9D 7F 17		        STA     ROFF,X
   490
   491 0860			GETDISC:
   492 				        ;LDA     DVSTAT+2    ; Did we disconnect?
   493 0860 AD ED 02		        LDA     DVSTAT+3    ; Did we disconnect?
   494 0863 D0 04		        BNE     GETUPDP     ; nope, update the buffer cursor.
   495
   496 				        ;; We disconnected, emit an EOF.
   497
   498 0865			RETEOF:
   499 0865 A0 88		        LDY     #EOF
   500 0867 98			        TYA
   501 0868 60			        RTS                 ; buh-bye.
   502
   503 0869			GETUPDP:
   504 0869 DE 7B 17		        DEC     RLEN,X      ; Decrement RX length.
   505 086C BC 7F 17		        LDY     ROFF,X      ; Get RX offset cursor.
   506
   507 				        ;; Return Next char from appropriate RX buffer.
   508
   509 086F B9 00 18		        LDA     RBUF,Y
   510
   511 				        ;; Increment RX offset
   512
   513 0872 FE 7F 17		GX:     INC     ROFF,X      ; Increment RX offset.
   514 0875 A8			        TAY                 ; stuff returned val into Y temporarily.
   515
   516 				        ;; If requested RX buffer is empty, reset TRIP.
   517
   518 0876 BD 7B 17		        LDA     RLEN,X
   519 0879 D0 03		        BNE     GETDONE
   520 087B 8D 7A 17		        STA     TRIP
   521
   522 				        ;; Return byte back to CIO.
   523
   524 087E			GETDONE:
   525 087E 98			        TYA                 ; Move returned val back.
   526 087F A0 01		        LDY     #$01        ; SUCCESS
   527
   528 0881 60			        RTS                 ; DONE...
   529
   530 0882			GETDCB:
   531 0882 71			       .BYTE    DEVIDN      ; DDEVIC
   532 0883 FF			       .BYTE    $FF         ; DUNIT
   533 0884 52			       .BYTE    'R'         ; DCOMND
   534 0885 40			       .BYTE    $40         ; DSTATS
   535 0886 00			       .BYTE    <RBUF       ; DBUFL
   536 0887 18			       .BYTE    >RBUF       ; DBUFH
   537 0888 0F			       .BYTE    $0F         ; DTIMLO
   538 0889 00			       .BYTE    $00         ; DRESVD
   539 088A FF			       .BYTE    $FF         ; DBYTL
   540 088B 00			       .BYTE    $00         ; DBYTH
   541 088C FF			       .BYTE    $FF         ; DAUX1
   542 088D 00			       .BYTE    $00         ; DAUX2
   543
   544 				; End CIO GET
   545 				;---------------------------------------
   546
   547 				;---------------------------------------
   548 				; CIO PUT
   549 				;---------------------------------------
   550
   551 088E			PUT:    ;; Add to TX buffer.
   552
   553 088E 20 5C 0A		        JSR     GDIDX
   554 0891 BC 83 17		        LDY     TOFF,X      ; GET TX cursor.
   555 0894 99 80 18		        STA     TBUF,Y      ; TX Buffer
   556
   557 0897 FE 83 17		POFF:   INC     TOFF,X      ; Increment TX cursor
   558 089A A0 01		        LDY     #$01        ; SUCCESSFUL
   559
   560 				        ;; Do a PUT FLUSH if EOL or buffer full.
   561
   562 089C C9 9B		        CMP     #EOL        ; EOL?
   563 089E F0 0B		        BEQ     FLUSH       ; FLUSH BUFFER
   564 08A0 20 5C 0A		        JSR     GDIDX       ; GET OFFSET
   565 08A3 BD 83 17		        LDA     TOFF,X
   566 08A6 C9 7F		        CMP     #$7F        ; LEN = $FF?
   567 08A8 F0 01		        BEQ     FLUSH       ; FLUSH BUFFER
   568 08AA 60			        RTS
   569
   570 				       ; FLUSH BUFFER, IF ASKED.
   571
   572 08AB 20 AF 08		FLUSH:  JSR     PFLUSH      ; FLUSH BUFFER
   573 08AE 60			        RTS
   574
   575 08AF			PFLUSH:
   576
   577 				       ; CHECK CONNECTION, AND EOF
   578 				       ; IF DISCONNECTED.
   579
   580 08AF 20 24 09		        JSR     STPOLL      ; GET STATUS
   581 08B2 AD ED 02		        LDA     DVSTAT+3
   582 08B5 F0 AE		        BEQ     RETEOF
   583
   584 08B7 20 5C 0A		PF1:    JSR     GDIDX       ; GET DEV X
   585 08BA BD 83 17		        LDA     TOFF,X
   586 08BD D0 03		        BNE     PF2
   587 08BF 4C DF 08		        JMP     PDONE
   588
   589 				       ; FILL OUT DCB FOR PUT FLUSH
   590
   591 08C2 A5 21		PF2:    LDA     ZICDNO
   592 08C4 8D E3 08		        STA     PUTDCB+1
   593
   594 				       ; FINISH DCB AND DO SIOV
   595
   596 08C7 BD 83 17		TBX:    LDA     TOFF,X
   597 08CA 8D EA 08		        STA     PUTDCB+8
   598 08CD 8D EC 08		        STA     PUTDCB+10
   599
   600 08D0 A9 E2		        LDA     #<PUTDCB
   601 08D2 A0 08		        LDY     #>PUTDCB
   602 08D4 20 A5 07		        JSR     DOSIOV
   603
   604 				        ; CLEAR THE OFFSET CURSOR
   605 				        ; AND LENGTH
   606
   607 08D7 20 5C 0A		        JSR     GDIDX
   608 08DA A9 00		        LDA     #$00
   609 08DC 9D 83 17		        STA     TOFF,X
   610
   611 08DF A0 01		PDONE:  LDY     #$01
   612 08E1 60			        RTS
   613
   614 08E2 71			PUTDCB .BYTE    DEVIDN      ; DDEVIC
   615 08E3 FF			       .BYTE    $FF         ; DUNIT
   616 08E4 57			       .BYTE    'W'         ; DCOMND
   617 08E5 80			       .BYTE    $80         ; DSTATS
   618 08E6 80			       .BYTE    $80         ; DBUFL
   619 08E7 18			       .BYTE    >TBUF       ; DBUFH
   620 08E8 0F			       .BYTE    $0F         ; DTIMLO
   621 08E9 00			       .BYTE    $00         ; DRESVD
   622 08EA FF			       .BYTE    $FF         ; DBYTL
   623 08EB 00			       .BYTE    $00         ; DBYTH
   624 08EC FF			       .BYTE    $FF         ; DAUX1
   625 08ED 00			       .BYTE    $00         ; DAUX2
   626
   627 				; End CIO PUT
   628 				;---------------------------------------
   629
   630 				;---------------------------------------
   631 				; CIO STATUS 
   632 				;---------------------------------------
   633
   634 08EE 20 4A 0A		STATUS: JSR     ENPRCD      ; ENABLE PRCD
   635 08F1 20 5C 0A		        JSR     GDIDX       ; GET DEVICE#
   636 08F4 BD 7B 17		        LDA     RLEN,X      ; GET RLEN
   637 08F7 D0 05		        BNE     STSLEN      ; RLEN > 0?
   638 08F9 AD 7A 17		        LDA     TRIP
   639 08FC D0 15		        BNE     STTRI1      ; TRIP = 1?
   640
   641 				        ; NO TRIP, RETURN SAVED LEN
   642
   643 08FE BD 7B 17		STSLEN: LDA     RLEN,X      ; GET RLEN
   644 0901 8D EA 02		        STA     DVSTAT      ; RET IN DVSTAT
   645
   646 				        ; If you don't need to preserve Y then use it instead of A
   647 0904 A9 00		        LDA     #$00
   648 0906 8D EB 02		        STA     DVSTAT+1
   649
   650 				        ; and INY here
   651 0909 A9 01		        LDA     #$01
   652 090B 8D EC 02		        STA     DVSTAT+2
   653 090E 8D ED 02		        STA     DVSTAT+3
   654
   655 0911 D0 0B		        BNE     STDONE
   656
   657 				        ; DO POLL AND UPDATE RCV LEN
   658
   659 0913 20 24 09		STTRI1: JSR     STPOLL      ; POLL FOR ST
   660 0916 9D 7B 17		        STA     RLEN,X
   661
   662 				        ; UPDATE TRIP FLAG
   663
   664 0919 D0 03		STTRIU: BNE     STDONE
   665 091B 8D 7A 17		        STA     TRIP        ; RLEN = 0
   666
   667 				        ; RETURN CONNECTED? FLAG.
   668
   669 091E AD EC 02		STDONE: LDA     DVSTAT+2
   670 0921 A0 01		        LDY     #$01
   671 0923 60			        RTS
   672
   673 				       ; ASK FUJINET FOR STATUS
   674
   675 0924			STPOLL:
   676 0924 A5 21		        LDA     ZICDNO      ; IOCB #
   677 0926 8D 49 09		        STA     STADCB+1
   678
   679 0929 A9 48		        LDA     #<STADCB
   680 092B A0 09		        LDY     #>STADCB
   681
   682 092D 20 A5 07		        JSR     DOSIOV
   683
   684 				        ;; > 127 bytes? make it 127 bytes.
   685
   686 0930 AD EB 02		        LDA     DVSTAT+1
   687 0933 D0 07		        BNE     STADJ
   688 0935 AD EA 02		        LDA     DVSTAT
   689 0938 30 02		        BMI     STADJ
   690 093A 50 08		        BVC     STP2        ; <= 127 bytes...
   691
   692 093C A9 7F		STADJ   LDA     #$7F
   693 093E 8D EA 02		        STA     DVSTAT
   694 				        
   695 0941 8D EB 02		        STA     DVSTAT+1
   696
   697 				       ; A = CONNECTION STATUS
   698
   699 0944 AD EC 02		STP2:   LDA     DVSTAT+2
   700 0947 60			        RTS
   701
   702 0948 71			STADCB: .BYTE   DEVIDN      ; DDEVIC
   703 0949 FF			        .BYTE   $FF         ; DUNIT
   704 094A 53			        .BYTE   'S'         ; DCOMND
   705 094B 40			        .BYTE   $40         ; DSTATS
   706 094C EA			        .BYTE   <DVSTAT     ; DBUFL
   707 094D 02			        .BYTE   >DVSTAT     ; DBUFH
   708 094E 0F			        .BYTE   $0F         ; DTIMLO
   709 094F 00			        .BYTE   $00         ; DRESVD
   710 0950 04			        .BYTE   $04         ; DBYTL
   711 0951 00			        .BYTE   $00         ; DBYTH
   712 0952 00			        .BYTE   $00         ; DAUX1
   713 0953 00			        .BYTE   $00         ; DAUX2
   714
   715 				; End CIO STATUS
   716 				;---------------------------------------
   717
   718 				;---------------------------------------
   719 				; CIO SPECIAL
   720 				;---------------------------------------
   721
   722 0954			SPEC:   ; HANDLE LOCAL COMMANDS.
   723
   724 0954 A5 22		        LDA     ZICCOM
   725 0956 C9 0F		        CMP     #$0F        ; 15 = FLUSH
   726 0958 D0 06		        BNE     S1          ; NO.
   727 095A 20 AF 08		        JSR     PFLUSH      ; DO FLUSH
   728 095D A0 01		        LDY     #$01        ; SUCCESS
   729 095F 60			        RTS
   730
   731 0960 C9 28		S1:     CMP     #40         ; 40 = LOAD AND EXECUTE
   732 0962 F0 03		        BEQ     S2          ; YES.
   733 0964 4C 68 09		        JMP     S3          ; NO. SKIP OVER spec40
   734
   735 0967 60			S2:     RTS
   736 				       ; HANDLE SIO COMMANDS.
   737 				       ; GET DSTATS FOR COMMAND
   738 0968			S3:
   739 0968 A5 21		        LDA     ZICDNO
   740 096A 8D B0 09		        STA     SPEDCB+1
   741 096D A5 22		        LDA     ZICCOM
   742 096F 8D B9 09		        STA     SPEDCB+10
   743
   744 0972 A9 AF		        LDA     #<SPEDCB
   745 0974 A0 09		        LDY     #>SPEDCB
   746 0976 20 A5 07		        JSR     DOSIOV
   747
   748 0979 30 0A		        BMI     :DSERR
   749
   750 				       ; WE GOT A DSTATS INQUIRY
   751 				       ; IF $FF, THE COMMAND IS
   752 				       ; INVALID
   753
   754 097B AD 87 17		DSOK:   LDA     INQDS
   755 097E C9 FF		        CMP     #$FF        ; INVALID?
   756 0980 D0 04		        BNE     DSGO        ; DO THE CMD
   757 0982 A0 92		        LDY     #$92        ; UNIMP CMD
   758 0984 98			        TYA
   759 0985			DSERR:
   760 0985 60			        RTS
   761
   762 				        ;; Do the special, since we want to pass in all the IOCB
   763 				        ;; Parameters to the DCB, This is being done long-hand.
   764
   765 0986 A5 22		DSGO:   LDA     ZICCOM
   766 0988 48			        PHA
   767 0989 A9 00		        LDA     #$00
   768 098B 48			        PHA
   769 098C AD 87 17		        LDA     INQDS
   770 098F 48			        PHA
   771 0990 A9 01		        LDA     #$01
   772 0992 48			        PHA
   773 0993 A5 24		        LDA     ZICBAL
   774 0995 48			        PHA
   775 0996 A5 2A		        LDA     ZICAX1
   776 0998 48			        PHA
   777 0999 A5 25		        LDA     ZICBAH
   778 099B 48			        PHA
   779 099C A5 2B		        LDA     ZICAX2
   780 099E 48			        PHA
   781 099F A0 03		        LDY     #$03
   782 09A1			DSGOL:
   783 09A1 68			        PLA
   784 09A2 99 08 03		        STA     DBYTL,Y
   785 09A5 68			        PLA
   786 09A6 99 02 03		        STA     DCOMND,Y
   787 09A9 88			        DEY
   788 09AA 10 F5		        BPL     DSGOL
   789
   790 09AC 4C B6 07		        JMP     SIOVDST
   791
   792 				        ;; Return DSTATS in Y and A
   793
   794 09AF 71			SPEDCB  .BYTE   DEVIDN      ; DDEVIC
   795 09B0 FF			        .BYTE   $FF         ; DUNIT
   796 09B1 FF			        .BYTE   $FF         ; DCOMND ; inq
   797 09B2 40			        .BYTE   $40         ; DSTATS
   798 09B3 87			        .BYTE   <INQDS      ; DBUFL
   799 09B4 17			        .BYTE   >INQDS      ; DBUFH
   800 09B5 0F			        .BYTE   $0F         ; DTIMLO
   801 09B6 00			        .BYTE   $00         ; DRESVD
   802 09B7 01			        .BYTE   $01         ; DBYTL
   803 09B8 00			        .BYTE   $00         ; DBYTH
   804 09B9 FF			        .BYTE   $FF         ; DAUX1
   805 09BA FF			        .BYTE   $FF         ; DAUX2
   806
   807 				; End CIO SPECIAL
   808 				;---------------------------------------
   809
   810 				;#######################################
   811 				;#                                     #
   812 				;#             CIO Functions           # 
   813 				;#                                     #
   814 				;#######################################
   815
   816
   817 				;---------------------------------------
   818 09BB			CIOCLOSE:
   819 				;---------------------------------------
   820 				    ; X must contain IOCB offset ($10,$20,..)
   821 09BB A9 0C		        LDA     #$0C            ; Close #1 first
   822 09BD 9D 42 03		        STA     ICCOM,X
   823 09C0 4C 56 E4		        JMP     CIOV
   824
   825 				;---------------------------------------
   826 09C3			CIOOPEN:
   827 				;---------------------------------------
   828 				    ; Input: 
   829 				    ; X = IOCB offset ($10,$20,..)
   830 				    ; Y = data direction (4=inp,8=out,12=i/o)
   831 				    ; INBUFF contains ICBAL/H
   832 09C3 A9 03		        LDA     #$03            ; 3 = CIO 'OPEN FILE'
   833 09C5 9D 42 03		        STA     ICCOM,X
   834 09C8 A5 F3		        LDA     INBUFF          ; Pointer to filename
   835 09CA 9D 44 03		        STA     ICBAL,X
   836 09CD A5 F4		        LDA     INBUFF+1        ; Pointer to filename
   837 09CF 9D 45 03		        STA     ICBAH,X
   838 09D2 98			        TYA
   839 09D3 9D 4A 03		        STA     ICAX1,X         ; Data direction
   840 09D6 A9 00		        LDA     #$00
   841 09D8 9D 4B 03		        STA     ICAX2,X         ; Unused
   842 09DB 20 56 E4		        JSR     CIOV            ; Call CIO
   843 09DE 20 A4 0A		        JSR     PRINT_ERROR
   844
   845 09E1			CIOOPEN_DONE:
   846 09E1 60			        RTS
   847
   848 				;---------------------------------------
   849 09E2			CIOSTATUS:
   850 				;---------------------------------------
   851 09E2 A9 0D		        LDA     #$0D
   852 09E4 9D 42 03		        STA     ICCOM,X
   853 09E7 20 56 E4		        JSR     CIOV
   854 09EA 10 03		        BPL     CIOSTATUS_DONE
   855 09EC 20 A4 0A		        JSR     PRINT_ERROR
   856
   857 09EF			CIOSTATUS_DONE:
   858 09EF 60			        RTS
   859 				        
   860
   861 				;---------------------------------------
   862 09F0			CIOGET:
   863 				;---------------------------------------
   864 				    ; Input: 
   865 				    ; X = IOCB offset ($10,$20,..)
   866 				    ; A = ICBLL
   867 				    ; Y = ICBLH
   868 				    ; INBUFF contains ICBAL/H
   869 09F0 48			        PHA                 ; Stash Buffer length Lo
   870 09F1 A9 07		        LDA     #$07        ; GET BYTES command
   871 09F3 9D 42 03		        STA     ICCOM,X
   872 09F6 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   873 09F8 9D 44 03		        STA     ICBAL,X
   874 09FB A5 F4		        LDA     INBUFF+1
   875 09FD 9D 45 03		        STA     ICBAH,X
   876 0A00 68			        PLA                 ; Retrieve Buffer length Lo
   877 0A01 9D 48 03		        STA     ICBLL,X
   878 0A04 98			        TYA                 ; Get Buffer length Hi
   879 0A05 9D 49 03		        STA     ICBLH,X
   880 0A08 20 56 E4		        JSR     CIOV        ; Bon voyage
   881 0A0B 10 00		        BPL     CIOGET_DONE
   882 				;        JMP     PRINT_ERROR
   883
   884 0A0D			CIOGET_DONE:
   885 0A0D 60			        RTS
   886
   887 				;---------------------------------------
   888 0A0E			CIOPUT:
   889 				;---------------------------------------
   890 				    ; Input: 
   891 				    ; X = IOCB offset ($10,$20,..)
   892 				    ; A = ICBLL
   893 				    ; Y = ICBLH
   894 				    ; INBUFF contains ICBAL/H
   895 0A0E 48			        PHA                 ; Stash Buffer length Lo
   896 0A0F A9 0B		        LDA     #$0B        ; PUT BYTES command
   897 0A11 9D 42 03		        STA     ICCOM,X
   898 0A14 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   899 0A16 9D 44 03		        STA     ICBAL,X
   900 0A19 A5 F4		        LDA     INBUFF+1
   901 0A1B 9D 45 03		        STA     ICBAH,X
   902 0A1E 68			        PLA                 ; Retrieve Buffer length Lo
   903 0A1F 9D 48 03		        STA     ICBLL,X
   904 0A22 98			        TYA                 ; Get Buffer length Hi
   905 0A23 9D 49 03		        STA     ICBLH,X
   906 0A26 20 56 E4		        JSR     CIOV        ; Bon voyage
   907 0A29 10 00		        BPL     CIOPUT_DONE
   908 				;        JMP     PRINT_ERROR
   909
   910 0A2B			CIOPUT_DONE:
   911 0A2B 60			        RTS
   912
   913 				;---------------------------------------
   914 0A2C			CIOGETREC:
   915 				;---------------------------------------
   916 				    ; Input: 
   917 				    ; X = IOCB offset ($10,$20,..)
   918 				    ; A = ICBLL
   919 				    ; Y = ICBLH
   920 				    ; INBUFF contains ICBAL/H
   921 0A2C 48			        PHA                 ; Stash Buffer length Lo
   922 0A2D A9 05		        LDA     #$05        ; GET RECORD command
   923 0A2F 9D 42 03		        STA     ICCOM,X
   924 0A32 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   925 0A34 9D 44 03		        STA     ICBAL,X
   926 0A37 A5 F4		        LDA     INBUFF+1
   927 0A39 9D 45 03		        STA     ICBAH,X
   928 0A3C 68			        PLA                 ; Retrieve Buffer length Lo
   929 0A3D 9D 48 03		        STA     ICBLL,X
   930 0A40 98			        TYA                 ; Get Buffer length Hi
   931 0A41 9D 49 03		        STA     ICBLH,X
   932
   933 0A44 20 56 E4		        JSR     CIOV        ; Bon voyage
   934 0A47 10 00		        BPL     CIOGETREC_DONE
   935 				;        JMP     PRINT_ERROR
   936
   937 0A49			CIOGETREC_DONE:
   938 0A49 60			        RTS
   939
   940 				;#######################################
   941 				;#                                     #
   942 				;#          Utility Functions          #
   943 				;#                                     #
   944 				;#######################################
   945 				        ; ENABLE PROCEED INTERRUPT
   946
   947 0A4A AD 02 D3		ENPRCD: LDA     PACTL
   948 0A4D 09 01		        ORA     #$01        ; ENABLE BIT 0
   949 0A4F 8D 02 D3		        STA     PACTL
   950 0A52 60			        RTS
   951
   952 				       ; DISABLE PROCEED INTERRUPT
   953
   954 0A53 AD 02 D3		DIPRCD: LDA     PACTL
   955 0A56 29 FE		        AND     #$FE        ; DISABLE BIT0
   956 0A58 8D 02 D3		        STA     PACTL
   957 0A5B 60			        RTS
   958
   959 				       ; GET ZIOCB DEVNO - 1 INTO X
   960
   961 0A5C A6 21		GDIDX:  LDX     ZICDNO      ; IOCB UNIT #
   962 0A5E CA			        DEX                 ; - 1
   963 0A5F 60			        RTS
   964
   965 				    ; Convert char in A from upper-case to lower-case
   966 0A60			TOUPPER:
   967 0A60 C9 61		        CMP     #'a'        ; SKip if < 'a'
   968 0A62 90 06		        BCC     @+
   969 0A64 C9 7B		        CMP     #'z'+1      ; Skip if > 'z'
   970 0A66 B0 02		        BCS     @+
   971 0A68 29 5F		        AND     #$5F        ; Disable high-bit and convert to lower
   972 0A6A 60			 @:     RTS
   973
   974 				;---------------------------------------
   975 				; Proceed Vector
   976 				;---------------------------------------
   977
   978 0A6B A9 01		PRCVEC: LDA     #$01
   979 0A6D 8D 7A 17		        STA     TRIP
   980 0A70 68			        PLA
   981 0A71 40			        RTI
   982
   983 				; End Proceed Vector
   984 				;---------------------------------------
   985
   986 				;---------------------------------------
   987 				; Reset LNBUF
   988 				;---------------------------------------
   989 				; Normally this routine is at $DA51
   990 				; But some programs will bank-switch
   991 				; that portion of ROM to RAM
   992 				;---------------------------------------
   993
   994 				;LDBUFA: LDA     #$05
   995 				;        STA     INBUFF+1
   996 				;        LDA     #$82        ; Normally $80. 2 for headroom
   997 				;        STA     INBUFF
   998 				;        RTS
   999 0A72 A9 18		LDBUFA: LDA     #$18
  1000 0A74 85 F4		        STA     INBUFF+1
  1001 0A76 A9 80		        LDA     #$80        ; Normally $80. 2 for headroom
  1002 0A78 85 F3		        STA     INBUFF
  1003 0A7A 60			        RTS
  1004
  1005 				; End Reset LNBUF
  1006 				;---------------------------------------
  1007
  1008 				;---------------------------------------
  1009 				; Skip spaces
  1010 				;---------------------------------------
  1011 				; Normally this routine is at $DBA1
  1012 				; But some programs will bank-switch
  1013 				; that portion of ROM to RAM
  1014 				;---------------------------------------
  1015
  1016 0A7B A4 F2		SKPSPC: LDY     CIX
  1017 0A7D A9 20		        LDA     #$20
  1018 0A7F D1 F3		@:      CMP     (INBUFF),Y
  1019 0A81 D0 03		        BNE     @+
  1020 0A83 C8			        INY
  1021 0A84 D0 F9		        BNE     @-
  1022 0A86 84 F2		@:      STY     CIX
  1023 0A88 60			        RTS
  1024
  1025 				; End SKPSPC
  1026 				;---------------------------------------
  1027
  1028 				;---------------------------------------
  1029 				; Print EOL-terminated string
  1030 				; A: String Buffer Lo
  1031 				; Y: String Buffer Hi
  1032 				;---------------------------------------
  1033 0A89			PRINT_STRING:
  1034
  1035 0A89 A2 00		        LDX     #$00
  1036 				    ;---------------------------------------
  1037 				    ; String Buffer
  1038 				    ;---------------------------------------
  1039 0A8B 9D 44 03		        STA     ICBAL,X
  1040 0A8E 98			        TYA
  1041 0A8F 9D 45 03		        STA     ICBAH,X
  1042
  1043 				    ;---------------------------------------
  1044 				    ; String Length
  1045 				    ;---------------------------------------
  1046 0A92 A9 80		        LDA     #$80
  1047 0A94 9D 48 03		        STA     ICBLL,X
  1048 0A97 A9 00		        LDA     #$00
  1049 0A99 9D 49 03		        STA     ICBLH,X
  1050
  1051 				    ;---------------------------------------
  1052 				    ; Call to CIO
  1053 				    ;---------------------------------------
  1054 0A9C A9 09		        LDA     #PUTREC
  1055 0A9E 9D 42 03		        STA     ICCOM,X
  1056 0AA1 4C 56 E4		        JMP     CIOV
  1057
  1058 				;---------------------------------------
  1059 				; Print integer error number from DOSIOV
  1060 				; Y: Return code from DOSIOV
  1061 				;---------------------------------------
  1062 0AA4			PRINT_ERROR:
  1063 0AA4 C0 01		        CPY     #$01        ; Exit if success (1)
  1064 0AA6 F0 33		        BEQ     PRINT_ERROR_DONE
  1065
  1066 				    ;-----------------------------------
  1067 				    ; If error code = 144, then get
  1068 				    ; extended code from DVSTAT
  1069 				    ;-----------------------------------
  1070 0AA8 C0 90		        CPY     #144
  1071 0AAA D0 0A		        BNE     PRINT_ERROR_NEXT
  1072
  1073 0AAC A9 48		        LDA     #<STADCB
  1074 0AAE A0 09		        LDY     #>STADCB
  1075 0AB0 20 A5 07		        JSR     DOSIOV
  1076 0AB3 AC ED 02		        LDY     DVSTAT+3    ;
  1077
  1078 0AB6			PRINT_ERROR_NEXT:
  1079 				    ;-----------------------------------
  1080 				    ; Convert error code to ASCII
  1081 				    ;-----------------------------------
  1082 0AB6 84 D4		        STY     FR0
  1083 0AB8 A9 00		        LDA     #$00
  1084 0ABA 85 D5		        STA     FR0+1
  1085 0ABC 20 AA D9		        JSR     IFP         ; Convert error from int to floating point
  1086 0ABF 20 E6 D8		        JSR     FASC        ; Convert floating point to ASCII
  1087
  1088 				    ;---------------------------------------
  1089 				    ; Find last char in ASCII error (noted by high bit)
  1090 				    ; Unset high bit & append EOL
  1091 				    ;---------------------------------------
  1092 0AC2 A0 FF		        LDY     #$FF        ; Init counter = 0
  1093
  1094 0AC4 C8			@       INY
  1095 0AC5 B1 F3		        LDA     (INBUFF),Y
  1096 0AC7 C9 80		        CMP     #$80
  1097 0AC9 90 F9		        BCC     @-
  1098
  1099 0ACB 29 7F		        AND     #$7F        ; Clear high bit
  1100 0ACD 91 F3		        STA     (INBUFF),Y
  1101 0ACF C8			        INY
  1102 0AD0 A9 9B		        LDA     #EOL        ; Append EOL
  1103 0AD2 91 F3		        STA     (INBUFF),Y
  1104
  1105 0AD4 A5 F3		        LDA     INBUFF
  1106 0AD6 A4 F4		        LDY     INBUFF+1
  1107 0AD8 4C 89 0A		        JMP     PRINT_STRING
  1108
  1109 0ADB			PRINT_ERROR_DONE:
  1110 0ADB 60			        RTS
  1111
  1112 				; End Utility Functions
  1113 				;---------------------------------------
  1114
  1115
  1116 				;#######################################
  1117 				;#                                     #
  1118 				;#       COMMAND PROCESSOR (CP)        #
  1119 				;#                                     #
  1120 				;#######################################
  1121
  1122 				;---------------------------------------
  1123 				; DOS Entry point
  1124 				;---------------------------------------
  1125 0ADC			DOS:
  1126 				        ; Bypass Autorun if OPTION switch held
  1127 0ADC AD 1F D0		        LDA     CONSOL
  1128 0ADF C9 03		        CMP     #OPTION
  1129 0AE1 F0 0D		        BEQ     CPLOOP
  1130 				        ; Autorun injection
  1131 0AE3 A9 0D		        LDA     #CMD_IDX.AUTORUN    ; Check for AUTORUN
  1132 0AE5 CD 79 17		        CMP     AUTORUN_FLG         ; True only on 1st entry
  1133 0AE8 F0 06		        BEQ     CPLOOP              ; Skip to Command Processor
  1134 0AEA 8D 79 17		        STA     AUTORUN_FLG         ; Change flag
  1135 0AED 20 1B 12		        JSR     SUBMIT_AUTORUN      ; Attempt to execute autorun file
  1136 				       
  1137 0AF0			CPLOOP:
  1138 0AF0 20 F6 0A		        JSR     CP          ; Command Processor
  1139 0AF3 4C F0 0A		        JMP     CPLOOP      ; Keep looping
  1140
  1141
  1142 				;---------------------------------------
  1143 				; Main loop
  1144 				;---------------------------------------
  1145
  1146 0AF6			CP:
  1147 0AF6 A9 FF		        LDA     #$FF        ; Clear command
  1148 0AF8 8D 76 17		        STA     CMD
  1149
  1150 0AFB 20 0A 0B		        JSR     SHOWPROMPT
  1151 0AFE 20 2F 0B		        JSR     GETCMD
  1152 0B01			AUTORUN_DO:
  1153 0B01 20 9E 0B		        JSR     PARSECMD
  1154 0B04 30 03		        BMI     CP_DONE     ; Skip DOCMD if CMD == $FF
  1155 0B06 20 51 0C		        JSR     DOCMD
  1156 0B09			CP_DONE:
  1157 0B09 60			        RTS
  1158
  1159 				;---------------------------------------
  1160 				; Show Command Prompt (Nn:)
  1161 				; Leading EOF requires special CIOV call
  1162 				;---------------------------------------
  1163
  1164 				;---------------------------------------
  1165 0B0A			SHOWPROMPT:
  1166 				;---------------------------------------
  1167
  1168 0B0A AD 75 17		        LDA     DOSDR       ; Get the 1,2,... for N1,N2,...
  1169 0B0D 09 30		        ORA     #'0'        ; Convert, say, 1 to '1'
  1170 0B0F 8D 1A 16		        STA     PRMPT+2     ; Store in after EOL and N
  1171
  1172 0B12 A2 00		        LDX     #$00
  1173 0B14 A9 0B		        LDA     #PUTCHR
  1174 0B16 9D 42 03		        STA     ICCOM,X
  1175
  1176 0B19 A9 18		        LDA     #<PRMPT
  1177 0B1B 9D 44 03		        STA     ICBAL,X
  1178 0B1E A9 16		        LDA     #>PRMPT
  1179
  1180 0B20 9D 45 03		        STA     ICBAH,X
  1181 0B23 A9 04		        LDA     #4          ; Prompt length = 4
  1182 0B25 9D 48 03		        STA     ICBLL,X
  1183 0B28 8A			        TXA                 ; Still zero
  1184 0B29 9D 49 03		        STA     ICBLH,X
  1185
  1186 0B2C 4C 56 E4		        JMP     CIOV
  1187
  1188 				;---------------------------------------
  1189 0B2F			GETCMD:
  1190 				;---------------------------------------
  1191 0B2F A2 00		        LDX     #$00
  1192 0B31 A9 05		        LDA     #GETREC
  1193 0B33 9D 42 03		        STA     ICCOM,X
  1194 0B36 A9 80		        LDA     #<LNBUF
  1195 0B38 9D 44 03		        STA     ICBAL,X
  1196 0B3B A9 18		        LDA     #>LNBUF
  1197 0B3D 9D 45 03		        STA     ICBAH,X
  1198 0B40 A9 7F		        LDA     #$7F
  1199 0B42 9D 48 03		        STA     ICBLL,X
  1200 0B45 20 56 E4		        JSR     CIOV
  1201
  1202 0B48			GETCMDTEST:
  1203 0B48 A0 00		        LDY #$00
  1204 0B4A 84 F2		        STY CIX
  1205 0B4C 20 72 0A		        JSR LDBUFA      ; Reset LNBUF to $0580
  1206 0B4F 20 7B 0A		        JSR SKPSPC      ; Advance CIX to next space
  1207
  1208 				    ;---------------------------------------
  1209 				    ; CMDSEP is an sequence of bytes contains
  1210 				    ; indexes to chars following spaces
  1211 				    ; Iterate to clear CMDSEP bytes
  1212 				    ;---------------------------------------
  1213 0B52 98			        TYA                 ; A = 0
  1214 0B53 A2 02		        LDX     #$02        ; for X = 2 to 0 step -1
  1215 0B55			GETLOOP:
  1216 0B55 9D 9A 0B		        STA     CMDSEP,X
  1217 0B58 CA			        DEX
  1218 0B59 10 FA		        BPL     GETLOOP     ; next X
  1219
  1220 				    ; Initial Delimiter to space
  1221 0B5B A9 20		        LDA     #' '
  1222 0B5D 8D 9D 0B		        STA     DELIM
  1223
  1224 				    ;---------------------------------------
  1225 				    ; Loop until EOL is encountered
  1226 				    ;---------------------------------------
  1227 0B60 E8			        INX                 ; Reset X to 0
  1228 0B61			GETCMD_LOOP:
  1229 0B61 B1 F3		        LDA     (INBUFF),Y
  1230 0B63 C9 9B		        CMP     #EOL        ; Found EOL?
  1231 0B65 F0 32		        BEQ     GETCMD_DONE ; yes. skip
  1232 0B67 CD 9D 0B		        CMP     DELIM       ; Found space?
  1233 0B6A F0 03		        BEQ     GETCMD_REPL ; yes. Replace it
  1234 0B6C C8			        INY
  1235 0B6D D0 F2		        BNE     GETCMD_LOOP ; "always" non-zero
  1236
  1237 				    ;---------------------------------------
  1238 				    ; March through the cmd line and note
  1239 				    ; the positions of any args as delimited
  1240 				    ; by spaces or quotes. positions saved
  1241 				    ; in CMDSEP,X
  1242 				    ;---------------------------------------
  1243 0B6F			GETCMD_REPL:
  1244 0B6F A9 9B		        LDA     #EOL
  1245 0B71 91 F3		        STA     (INBUFF),Y
  1246 0B73 C8			        INY
  1247 0B74 B1 F3		        LDA     (INBUFF),Y  ; Skip any run of spaces
  1248 0B76 C9 20		        CMP     #' '
  1249 0B78 F0 F5		        BEQ     GETCMD_REPL ; Keep skipping spaces
  1250
  1251 				    ; Here if any run of spaces has ended
  1252 				    ; Are we standing on a double-quote?
  1253 0B7A C9 22		        CMP     #'"'
  1254 0B7C D0 12		        BNE     GETCMD_WR_OFFSET  ; No. Skip ahead
  1255
  1256 				    ; Here if curr char is a double-quote
  1257 0B7E C8			        INY                 ; Advance the command line index
  1258 0B7F A9 22		        LDA     #'"'        ; Is the curr delim a double-quote?
  1259 0B81 CD 9D 0B		        CMP     DELIM       ; If not, change delim to double-quote
  1260 0B84 D0 07		        BNE     GETCMD_DQ_DELIM
  1261
  1262 				    ; Here if curr delim is a double-quote
  1263 				    ; Switch delim to space
  1264 0B86 A9 20		        LDA     #' '
  1265 0B88 8D 9D 0B		        STA     DELIM
  1266 0B8B D0 03		        BNE     GETCMD_WR_OFFSET
  1267
  1268 				    ; Here if curr delim is space
  1269 				    ; Switch delim to double-quote
  1270 0B8D			GETCMD_DQ_DELIM:
  1271 0B8D 8D 9D 0B		        STA     DELIM
  1272
  1273 				    ; Note the position for the curr command-line arg
  1274 0B90			GETCMD_WR_OFFSET:
  1275 0B90 98			        TYA
  1276 0B91 9D 9A 0B		        STA     CMDSEP,X
  1277 0B94 E8			        INX
  1278 0B95 E0 03		        CPX     #$03
  1279 0B97 90 C8		        BCC     GETCMD_LOOP ; Continue searching
  1280
  1281 0B99			GETCMD_DONE:
  1282 0B99 60			        RTS
  1283
  1284 0B9A FF FF FF		CMDSEP: .BYTE $FF,$FF,$FF
  1285 0B9D 20			DELIM:  .BYTE ' '
  1286
  1287 				;---------------------------------------
  1288 0B9E			PARSECMD:
  1289 				;---------------------------------------
  1290 				        ;LDA     LNBUF
  1291 0B9E A0 00		        LDY     #$00
  1292 0BA0 B1 F3		        LDA     (INBUFF),Y
  1293 0BA2 C9 9B		        CMP     #EOL        ; Quit immediately if no cmd
  1294 0BA4 F0 0C		        BEQ     PARSECMD_DONE
  1295
  1296 0BA6 20 C7 0B		        JSR     PARSE_INTRINSIC_COMMAND
  1297 0BA9 20 01 0C		        JSR     PARSE_DRIVE_CHANGE
  1298 0BAC 20 18 0C		        JSR     PARSE_EXTRINSIC_COMMAND
  1299 0BAF 20 B3 0B		        JSR     PRINT_UNK_CMD
  1300 0BB2			PARSECMD_DONE:
  1301 0BB2 60			        RTS
  1302
  1303 0BB3			PRINT_UNK_CMD:
  1304 0BB3 AD 76 17		        LDA     CMD
  1305 0BB6 C9 FF		        CMP     #$FF
  1306 0BB8 D0 07		        BNE     PRINT_UNK_CMD_DONE
  1307 0BBA A9 C2		        LDA     #<UNK_CMD_ERR
  1308 0BBC A0 0B		        LDY     #>UNK_CMD_ERR
  1309 0BBE 20 89 0A		        JSR     PRINT_STRING
  1310 0BC1			PRINT_UNK_CMD_DONE:
  1311 0BC1 60			        RTS
  1312
  1313 0BC2			UNK_CMD_ERR:
  1314 0BC2 43 4D 44 3F 9B	        .BYTE   'CMD?',EOL
  1315
  1316 				;---------------------------------------
  1317 0BC7			PARSE_INTRINSIC_COMMAND:
  1318 				;---------------------------------------
  1319 0BC7 A2 00		        LDX     #$00        ; Initialize X for command code indexing
  1320 0BC9 A0 00		        LDY     #$00
  1321 0BCB 84 F2		        STY     CIX
  1322 0BCD 20 72 0A		        JSR     LDBUFA      ; Set INBUFF to $0580, er make that TBUF
  1323
  1324 0BD0 20 7B 0A		@:      JSR     SKPSPC      ; Skip whitespace
  1325
  1326 0BD3			PARSE_INTRINSIC_NEXT_CHAR:
  1327 0BD3 B1 F3		        LDA     (INBUFF),Y
  1328 0BD5 29 5F		        AND     #$5F        ; Disable high-bit and convert to upper
  1329 0BD7 5D 38 16		        EOR     COMMAND,X   ; X initialized to 0 in caller
  1330 0BDA C8			        INY
  1331 0BDB 0A			        ASL
  1332 0BDC F0 0B		        BEQ     PARSE_INTRINSIC_CHAR_OK
  1333
  1334 				        ; Skip to next command
  1335
  1336 0BDE			PARSE_INTRINSIC_NEXT_COMMAND:
  1337 0BDE BD 38 16		        LDA     COMMAND,X
  1338 0BE1 0A			        ASL
  1339 0BE2 E8			        INX
  1340 0BE3 90 F9		        BCC     PARSE_INTRINSIC_NEXT_COMMAND
  1341 0BE5 A4 F2		        LDY     CIX
  1342 0BE7 E0 C4		        CPX     #COMMAND_SIZE
  1343
  1344 0BE9			PARSE_INTRINSIC_CHAR_OK:
  1345 0BE9 E8			        INX
  1346 0BEA 90 E7		        BCC     PARSE_INTRINSIC_NEXT_CHAR
  1347 0BEC 84 F2		        STY     CIX
  1348 0BEE B1 F3		        LDA     (INBUFF),Y
  1349 0BF0 30 05		        BMI     PARSE_INTRINSIC_RET
  1350
  1351 0BF2 20 7B 0A		        JSR     SKPSPC
  1352
  1353 0BF5			PARSE_INTRINSIC_RET_ERROR:
  1354 0BF5 A2 C5		        LDX     #COMMAND_SIZE+1
  1355 0BF7			PARSE_INTRINSIC_RET:
  1356 0BF7 BD 38 16		        LDA     COMMAND,X
  1357 0BFA 8D 76 17		        STA     CMD
  1358 0BFD 8D 77 17		        STA     CMDPRV
  1359 0C00			PARSE_INTRINSIC_DONE:
  1360 0C00 60			        RTS
  1361
  1362 				; End of PARSE_INTRINSIC_COMMAND
  1363 				;---------------------------------------
  1364
  1365 				;---------------------------------------
  1366 0C01			PARSE_DRIVE_CHANGE:
  1367 				;---------------------------------------
  1368 0C01 A2 03		        LDX     #$03        ; Check for EOL in pos 3
  1369 0C03 BD 80 18		        LDA     LNBUF,X
  1370 0C06 C9 9B		        CMP     #EOL
  1371 0C08 D0 0D		        BNE     PARSE_DRIVE_CHANGE_DONE
  1372 0C0A CA			        DEX                 ; go back one char
  1373 0C0B BD 80 18		        LDA     LNBUF,X
  1374 0C0E C9 3A		        CMP     #':'        ; Check for colon.
  1375 0C10 D0 05		        BNE     PARSE_DRIVE_CHANGE_DONE
  1376 0C12 A9 1B		        LDA     #CMD_IDX.DRIVE_CHG
  1377 0C14 8D 76 17		        STA     CMD
  1378 0C17			PARSE_DRIVE_CHANGE_DONE:
  1379 0C17 60			        RTS
  1380
  1381 				;---------------------------------------
  1382 0C18			PARSE_EXTRINSIC_COMMAND:
  1383 				;---------------------------------------
  1384 				    ; Quit if CMD has been found earlier
  1385 0C18 AE 76 17		        LDX     CMD         ; Undefined CMD = $FF
  1386 0C1B E8			        INX                 ; now 0 if undefined
  1387 0C1C D0 F9		        BNE     PARSE_DRIVE_CHANGE_DONE ; Exit if defined CMD
  1388
  1389 				    ; Here if  CMD is undefined.
  1390 				    ; From here we'll assume it's a filename for a executable
  1391 				    ; and attempt to LOAD it. But first append a ".COM"
  1392 				    ; and shift the filename to the right
  1393
  1394 				    ; Find offset to EOL
  1395 0C1E A0 FF		        LDY     #$FF
  1396 0C20 C8			@       INY
  1397 0C21 B1 F3		        LDA     (INBUFF),Y
  1398 0C23 C9 9B		        CMP     #EOL
  1399 0C25 D0 F9		        BNE     @-
  1400
  1401 				    ; Y contains offset to last char & stash it
  1402 0C27 98			        TYA
  1403 0C28 48			        PHA
  1404
  1405 				    ; Advance Y to allow the 5 chars of '.COM',EOL
  1406 0C29 18			        CLC
  1407 0C2A 69 05		        ADC     #$05
  1408 0C2C A8			        TAY
  1409
  1410 				    ; Append .COM, EOL
  1411 0C2D A2 04		        LDX     #$04
  1412 0C2F BD 4C 0C		@:      LDA     CMDEXT,X
  1413 0C32 91 F3		        STA     (INBUFF),Y
  1414 0C34 88			        DEY
  1415 0C35 CA			        DEX                     ; 
  1416 0C36 10 F7		        BPL     @-
  1417
  1418 				    ; Shift executable name to the right to allow room for PREPEND_DRIVE
  1419 				    ; Stack contains offset to last char
  1420 				    ; Y is still counting down from where '.COM' was appended.
  1421 0C38 68			        PLA                 ; Get offset to last char of executable
  1422 0C39 AA			        TAX                 ; It'll be used for indexing
  1423 0C3A CA			        DEX                 ; Skip original EOF
  1424 0C3B			SHIFT_LOOP:
  1425 0C3B BD 80 18		        LDA     LNBUF,X     ; Get source ch
  1426 0C3E 91 F3		@:      STA     (INBUFF),Y  ; Copy ch to new location
  1427 0C40 88			        DEY                 ; Point to next dest ch
  1428 0C41 CA			        DEX                 ; Point to next source ch
  1429 0C42 10 F7		        BPL     SHIFT_LOOP  ; Until X = 0
  1430
  1431 				    ; Let DO_LOAD attempt to execute the file
  1432 0C44 A9 01		        LDA     #$01        ; Point to start of filename
  1433 0C46 8D 9A 0B		        STA     CMDSEP      ; so DO_LOAD will treat it like
  1434 0C49 4C F7 0D		        JMP     DO_LOAD     ; 'LOAD filename'
  1435
  1436 0C4C			CMDEXT:
  1437 0C4C 2E 43 4F 4D 9B	        .BYTE   '.COM',EOL
  1438
  1439 				; End of PARSE_EXTRINSIC_COMMAND
  1440 				;---------------------------------------
  1441
  1442 				;---------------------------------------
  1443 0C51			DOCMD:
  1444 				;---------------------------------------
  1445 0C51 AE 76 17		        LDX     CMD
  1446 0C54 30 08		        BMI     DOCMD_DONE  ; Unassigned command = $FF
  1447 0C56 BD 1A 17		        LDA     CMD_TAB_H,X ; Get hi-byte of subroutine's addr
  1448 0C59 48			        PHA                 ; Push it to the stack
  1449 0C5A BD FE 16		        LDA     CMD_TAB_L,X ; Get lo-byte of subroutine's addr
  1450 0C5D 48			        PHA                 ; Push it to the stack
  1451 0C5E			DOCMD_DONE:
  1452 0C5E 60			        RTS                 ; Use stack & RTS to jump to subroutine
  1453
  1454 				; End of DOCMD
  1455 				;---------------------------------------
  1456
  1457 				;---------------------------------------
  1458 0C5F			DO_DRIVE_CHG:
  1459 				;---------------------------------------
  1460 0C5F AD 80 18		        LDA     LNBUF
  1461 0C62 8D 19 16		        STA     PRMPT+1
  1462 0C65 AD 81 18		        LDA     LNBUF+1
  1463 0C68 C9 31		        CMP     #'1'        ; Skip if < '1'
  1464 0C6A 90 0A		        BCC     DO_DRIVE_CHG_ERROR
  1465 0C6C C9 39		        CMP     #'9'        ; Skip if >= '9'
  1466 0C6E B0 06		        BCS     DO_DRIVE_CHG_ERROR
  1467 0C70 29 0F		        AND     #$0F        ; Convert, say, to 1-8
  1468 0C72 8D 75 17		        STA     DOSDR
  1469 0C75 60			        RTS
  1470 0C76			DO_DRIVE_CHG_ERROR:
  1471 0C76 A9 6B		        LDA     #<CDERR
  1472 0C78 A0 17		        LDY     #>CDERR
  1473 0C7A 4C 89 0A		        JMP     PRINT_STRING
  1474
  1475 				; End of DOCMD
  1476
  1477 				;---------------------------------------
  1478 				; Returns DOSDR in X
  1479 				; If arg1 contains Nn: then reg X = n
  1480 				; Otherwise X = DOSDR (from curr prompt)
  1481 				;---------------------------------------
  1482 0C7D			GET_DOSDR:
  1483 				;---------------------------------------
  1484
  1485 0C7D 20 72 0A		        JSR     LDBUFA      ; Reset INBUFF to LNBUF
  1486 0C80 AE 75 17		        LDX     DOSDR       ; Set DUNIT(X) to curr drive
  1487
  1488 				    ;---------------------------------------
  1489 				    ; Consider arg1 = N2:TNFS://localhost/
  1490 				    ; Check arg1 for ":" in 3rd position
  1491 				    ; if found then use char in 2nd position ('2') as DOSDR
  1492 				    ; First, change INBUFF to point to beg. of 1st arg
  1493 				    ;---------------------------------------
  1494 0C83 AD 9A 0B		        LDA     CMDSEP              ; arg offset
  1495 0C86 F0 17		        BEQ     GET_DOSDR_DONE      ; first, if arg1 not pop, leave X as-is & quit
  1496
  1497 0C88 18			        CLC                         ; Advance pointer to LNBUF
  1498 0C89 65 F3		        ADC     INBUFF
  1499 0C8B 85 F3		        STA     INBUFF
  1500 0C8D 90 02		        BCC     GET_DOSDR_NEXT
  1501 0C8F E6 F4		        INC     INBUFF+1
  1502
  1503 0C91			GET_DOSDR_NEXT:
  1504 0C91 A0 02		        LDY     #$02            ; Check for ':' in 3rd pos
  1505 0C93 B1 F3		        LDA     (INBUFF),Y
  1506 0C95 C9 3A		        CMP     #':'
  1507 0C97 D0 06		        BNE     GET_DOSDR_DONE  ; Not found, skip & use default
  1508 0C99 88			        DEY
  1509 0C9A B1 F3		        LDA     (INBUFF),Y
  1510 0C9C 29 0F		        AND     #$0F            ; Convert, say, '2' to 2
  1511 0C9E AA			        TAX                     ; Return DOSDR in X
  1512
  1513 0C9F			GET_DOSDR_DONE:
  1514 0C9F 60			        RTS
  1515
  1516 				;---------------------------------------
  1517 0CA0			DO_GENERIC:
  1518 				;---------------------------------------
  1519
  1520 				    ;---------------------------------------
  1521 				    ; SIO call for NCD,{MK,RM}DIR,DEL,RENAME
  1522 				    ;---------------------------------------
  1523
  1524 				    ;---------------------------------------
  1525 				    ; Get Fujinet SIO command (~ $21 for DEL)
  1526 				    ; X = table index from caller
  1527 				    ;---------------------------------------
  1528 0CA0 BD 1C 16		        LDA     CMD_DCOMND,X
  1529 0CA3 8D 03 0D		        STA     GENDCB+2
  1530
  1531 				    ;---------------------------------------
  1532 				    ; Get DOSDR from either arg1 or curr drive
  1533 				    ;---------------------------------------
  1534 0CA6 20 7D 0C		        JSR     GET_DOSDR    ; X will contain int of n in Nn:
  1535 0CA9 8E 02 0D		        STX     GENDCB+1
  1536 0CAC 20 C4 15		        JSR     PREPEND_DRIVE
  1537
  1538 				    ;---------------------------------------
  1539 				    ; If this is NCD ensure a '/' char is the last char
  1540 				    ;---------------------------------------
  1541 0CAF AD 03 0D		        LDA     GENDCB+2
  1542 0CB2 C9 2C		        CMP     #CMD_CD         ; Is this an NCD command?
  1543 0CB4 D0 08		        BNE     DO_GENERIC_NEXT ; No. skip
  1544
  1545 0CB6 AD 9A 0B		        LDA     CMDSEP
  1546 0CB9 F0 2C		        BEQ     NCD_ERROR
  1547 0CBB 20 F1 15		        JSR     APPEND_SLASH    ; Append '/' to path if missing
  1548
  1549 0CBE			DO_GENERIC_NEXT:
  1550 				    ;---------------------------------------
  1551 				    ; Populate the DCB
  1552 				    ;---------------------------------------
  1553 0CBE AD 75 17		        LDA     DOSDR
  1554 0CC1 8D 49 09		        STA     STADCB+1        ; Yes. Status (not typo)
  1555 				;        STA     GENDCB+1   ; 20221105 - commented-out. checking for bug...
  1556 0CC4 A5 F3		        LDA     INBUFF
  1557 0CC6 8D 05 0D		        STA     GENDCB+4
  1558 0CC9 A5 F4		        LDA     INBUFF+1
  1559 0CCB 8D 06 0D		        STA     GENDCB+5
  1560
  1561 				    ;---------------------------------------
  1562 				    ; Send the command to FujiNet
  1563 				    ;---------------------------------------
  1564 0CCE A9 01		        LDA     #<GENDCB
  1565 0CD0 A0 0D		        LDY     #>GENDCB
  1566 0CD2 20 A5 07		        JSR     DOSIOV
  1567 0CD5 20 A4 0A		        JSR     PRINT_ERROR
  1568
  1569 0CD8			GEN_UNMOUNT:
  1570 				    ;---------------------------------------
  1571 				    ; if DEL or RENAME, then remount drive
  1572 				    ;---------------------------------------
  1573 0CD8 AD 77 17		        LDA     CMDPRV
  1574 0CDB C9 02		        CMP     #CMD_IDX.DEL
  1575 0CDD F0 04		        BEQ     GEN_REMOUNT
  1576 0CDF C9 09		        CMP     #CMD_IDX.RENAME
  1577 0CE1 D0 03		        BNE     GENDONE
  1578 0CE3			GEN_REMOUNT:
  1579 0CE3 4C 91 15		        JMP     REMOUNT_DRIVE
  1580
  1581 0CE6			GENDONE:
  1582 0CE6 60			        RTS
  1583
  1584 				;---------------------------------------
  1585 0CE7			NCD_ERROR:
  1586 				;---------------------------------------
  1587 0CE7 A9 FB		        LDA     #<NCD_ERROR_STR
  1588 0CE9 A0 0C		        LDY     #>NCD_ERROR_STR
  1589 0CEB 20 89 0A		        JSR     PRINT_STRING
  1590 0CEE A0 01		        LDY     #$01        ; Return error
  1591 0CF0 60			        RTS
  1592 				    ;---------------------------------------
  1593 				    ; Close 
  1594 				    ;---------------------------------------
  1595 0CF1 A2 10		        LDX     #$10            ; File #1
  1596 0CF3 A9 0C		        LDA     #$0C            ; Close #1 first
  1597 0CF5 9D 42 03		        STA     ICCOM,X
  1598 0CF8 20 56 E4		        JSR     CIOV
  1599
  1600 0CFB			NCD_ERROR_STR:
  1601 0CFB 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  1602
  1603 				;---------------------------------------
  1604 0D01			GENDCB:
  1605 0D01 71			        .BYTE      DEVIDN  ; DDEVIC
  1606 0D02 FF			        .BYTE      $FF     ; DUNIT
  1607 0D03 FF			        .BYTE      $FF     ; DCOMND
  1608 0D04 80			        .BYTE      $80     ; DSTATS
  1609 0D05 FF			        .BYTE      $FF     ; DBUFL
  1610 0D06 FF			        .BYTE      $FF     ; DBUFH
  1611 0D07 1F			        .BYTE      $1F     ; DTIMLO
  1612 0D08 00			        .BYTE      $00     ; DRESVD
  1613 0D09 00			        .BYTE      $00     ; DBYTL
  1614 0D0A 01			        .BYTE      $01     ; DBYTH
  1615 0D0B 00			        .BYTE      $00     ; DAUX1
  1616 0D0C 00			        .BYTE      $00     ; DAUX2
  1617
  1618 				; End of DO_GENERIC
  1619 				;---------------------------------------
  1620
  1621 				;;---------------------------------------
  1622 				;DO_COPY:
  1623 				;;---------------------------------------
  1624 				;
  1625 				;        LDA     #$20
  1626 				;        STA     COLOR2
  1627 				;
  1628 				;        LDA     #<CPYDCB
  1629 				;        LDY     #>CPYDCB
  1630 				;        JSR     DOSIOV
  1631 				;
  1632 				;        LDA     #$20
  1633 				;        STA     COLOR2
  1634 				;
  1635 				;        RTS
  1636 				;
  1637 				;CPYDCB:
  1638 				;        .BYTE      DEVIDN  ; DDEVIC
  1639 				;        .BYTE      $FF     ; DUNIT
  1640 				;        .BYTE      $D8     ; DCOMND
  1641 				;        .BYTE      $80     ; DSTATS
  1642 				;        .BYTE      <COPYSPEC  ; DBUFL
  1643 				;        .BYTE      >COPYSPEC ; DBUFH
  1644 				;        .BYTE      $FE     ; DTIMLO
  1645 				;        .BYTE      $00     ; DRESVD
  1646 				;        .BYTE      $00     ; DBYTL
  1647 				;        .BYTE      $01     ; DBYTH
  1648 				;        .BYTE      3       ; DAUX1
  1649 				;        .BYTE      2       ; DAUX2
  1650 				;
  1651 				;COPYSPEC:
  1652 				;        .BYTE 'iss.po|iss.po',$00
  1653
  1654 				;;---------------------------------------
  1655 				;DO_COPY:
  1656 				;;---------------------------------------
  1657 				;        LDA     #$B0
  1658 				;        STA     COLOR2
  1659 				;        RTS
  1660
  1661 				;        JSR     COPY_PARSE_FILES    ; locate comma, replace with EOL
  1662 				;        BMI     COPY_DONE
  1663 				;
  1664 				;        LDA     CMDSEP
  1665 				;        STA     CMDSEP+2
  1666 				;
  1667 				;        LDA     CMDSEP+1
  1668 				;        STA     CMDSEP
  1669 				;
  1670 				;        JSR     COPY_OPEN_DEST      ; use CIO to open file 2 for write
  1671 				;        BMI     COPY_DONE
  1672 				;
  1673 				;        LDA     CMDSEP+2
  1674 				;        STA     CMDSEP
  1675 				;        JSR     COPY_OPEN_SRC       ; use CIO to open file 1 for read
  1676 				;        BMI     COPY_DONE
  1677 				;
  1678 				;@:      JSR     COPY_GET_SRC
  1679 				;        JSR     COPY_PUT_DEST
  1680 				;        ;BNE     @-
  1681 				;
  1682 				;COPY_DONE:
  1683 				;    ; Close files
  1684 				;        LDX     #$10
  1685 				;        JSR     CIOCLOSE
  1686 				;        LDX     #$20
  1687 				;        JMP     CIOCLOSE
  1688 				;
  1689 				;;---------------------------------------
  1690 				;COPY_PARSE_FILES:
  1691 				;;---------------------------------------
  1692 				;    ; Find position of comma in line buffer
  1693 				;    ; Return X = position of comma
  1694 				;    ;---------------------------------------
  1695 				;        LDX     CMDSEP
  1696 				;COPY_PARSE_LOOP:
  1697 				;        LDA     LNBUF,X
  1698 				;        CMP     #','
  1699 				;        BEQ     COPY_PARSE_FILES_DONE
  1700 				;        CMP     #EOL
  1701 				;        BEQ     COPY_SHOW_USAGE
  1702 				;        INX
  1703 				;        BNE     COPY_PARSE_LOOP
  1704 				;COPY_PARSE_FILES_DONE:
  1705 				;    ;---------------------------------------
  1706 				;    ; Here if comma found.
  1707 				;    ; Inject EOL where the comma was found
  1708 				;    ;---------------------------------------
  1709 				;        LDA     #EOL
  1710 				;        STA     LNBUF,X
  1711 				;        INX                 ; Advance to start of 2nd arg
  1712 				;        STX     CMDSEP+1    ; Point to 2nd arg now
  1713 				;        RTS
  1714 				;    ;---------------------------------------
  1715 				;    ; Here if no comma found.
  1716 				;    ; Print usage
  1717 				;    ;---------------------------------------
  1718 				;COPY_SHOW_USAGE:
  1719 				;        LDA     #<COPY_SHOW_USAGE_STR
  1720 				;        LDY     #>COPY_SHOW_USAGE_STR
  1721 				;        JSR     PRINT_STRING
  1722 				;        LDY     #$FF
  1723 				;        RTS
  1724 				;
  1725 				;COPY_SHOW_USAGE_STR:
  1726 				;        .BYTE   'COPY SOURCE,DEST',EOL
  1727 				;
  1728 				;; End of COPY_COMMA_POS:
  1729 				;;---------------------------------------
  1730 				;
  1731 				;;---------------------------------------
  1732 				;COPY_OPEN_SRC:
  1733 				;;---------------------------------------
  1734 				;        JSR     GET_DOSDR       ; Get DUNIT
  1735 				;        JSR     PREPEND_DRIVE
  1736 				;
  1737 				;        LDX     #$10            ; File #1
  1738 				;        JSR     CIOCLOSE        ; Assert file #1 is closed
  1739 				;        LDY     #$04            ; Open for input
  1740 				;        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  1741 				;        BPL     COPY_OPEN_SRC_DONE
  1742 				;
  1743 				;        LDA     #<COPY_OPEN_SRC_ERR_STR
  1744 				;        LDY     #>COPY_OPEN_SRC_ERR_STR
  1745 				;        JMP     PRINT_STRING
  1746 				;
  1747 				;COPY_OPEN_SRC_DONE:
  1748 				;        RTS
  1749 				;        
  1750 				;COPY_OPEN_SRC_ERR_STR:
  1751 				;        .BYTE   'UNABLE TO OPEN SOURCE',EOL
  1752 				;
  1753 				;;End of COPY_OPEN_SRC
  1754 				;;---------------------------------------
  1755 				;
  1756 				;;---------------------------------------
  1757 				;COPY_OPEN_DEST:
  1758 				;;---------------------------------------
  1759 				;    ; Advance offset to arg2
  1760 				;        
  1761 				;@:      JSR     GET_DOSDR       ; Get DUNIT
  1762 				;        JSR     PREPEND_DRIVE
  1763 				;
  1764 				;        LDX     #$20            ; Assert file #2 is closed
  1765 				;        JSR     CIOCLOSE
  1766 				;
  1767 				;        LDY     #$08            ; Open for write
  1768 				;        JSR     CIOOPEN
  1769 				;        BPL     COPY_OPEN_DEST_DONE  ; If success, skip ahead
  1770 				;
  1771 				;        LDA     #<COPY_OPEN_DEST_ERR_STR
  1772 				;        LDY     #>COPY_OPEN_DEST_ERR_STR
  1773 				;        JMP     PRINT_STRING
  1774 				;
  1775 				;COPY_OPEN_DEST_DONE:
  1776 				;        RTS
  1777 				;        
  1778 				;COPY_OPEN_DEST_ERR_STR:
  1779 				;        .BYTE   'UNABLE TO OPEN DEST',EOL
  1780 				;
  1781 				;;End of COPY_OPEN_SRC
  1782 				;;---------------------------------------
  1783 				;
  1784 				;;---------------------------------------
  1785 				;COPY_GET_SRC:
  1786 				;;---------------------------------------
  1787 				;        ;LDX     #$10
  1788 				;        ;JSR     CIOSTATUS
  1789 				;
  1790 				;        LDX     #$10
  1791 				;        LDA     #<TBUF
  1792 				;        STA     INBUFF      ; Buffer addr Lo
  1793 				;        LDA     #>TBUF
  1794 				;        STA     INBUFF+1    ; Buffer addr Hi
  1795 				;        LDA     #$80        ; Buffer size Lo
  1796 				;        LDY     #$00        ; Buffer size Hi
  1797 				;        JSR     CIOGET
  1798 				;        BPL     COPY_GET_SRC_DONE
  1799 				;        CPY     #EOF
  1800 				;        BEQ     COPY_GET_SRC_DONE
  1801 				; 
  1802 				;        LDA     #<COPY_GET_SRC_STR
  1803 				;        LDY     #>COPY_GET_SRC_STR
  1804 				;        JMP     PRINT_STRING
  1805 				;
  1806 				;COPY_GET_SRC_DONE:
  1807 				;        RTS
  1808 				;
  1809 				;COPY_GET_SRC_STR:
  1810 				;        .BYTE   'ERROR READING FROM SOURCE',EOL
  1811 				;
  1812 				;;---------------------------------------
  1813 				;COPY_PUT_DEST:
  1814 				;;---------------------------------------
  1815 				;        ;LDX     #$20
  1816 				;        ;JSR     CIOSTATUS
  1817 				;
  1818 				;        LDX     #$20
  1819 				;        LDA     #<TBUF
  1820 				;        STA     INBUFF      ; Buffer addr Lo
  1821 				;        LDA     #>TBUF
  1822 				;        STA     INBUFF+1    ; Buffer addr Hi
  1823 				;        LDA     #$06        ; Buffer size Lo
  1824 				;        LDY     #$00        ; Buffer size Hi
  1825 				;        JSR     CIOPUT
  1826 				;        BPL     COPY_PUT_DEST_DONE
  1827 				;        CPY     #EOF
  1828 				;        BEQ     COPY_PUT_DEST_DONE
  1829 				; 
  1830 				;        LDA     #<COPY_PUT_DEST_STR
  1831 				;        LDY     #>COPY_PUT_DEST_STR
  1832 				;        JMP     PRINT_STRING
  1833 				;
  1834 				;COPY_PUT_DEST_DONE:
  1835 				;        RTS
  1836 				;
  1837 				;COPY_PUT_DEST_STR:
  1838 				;        .BYTE   'ERROR WRITING TO DEST',EOL
  1839 				;
  1840
  1841 				;---------------------------------------
  1842 0D0D			DO_DIR:
  1843 				;---------------------------------------
  1844 0D0D 20 6D 0D		        JSR     DIR_INIT    ; set dunits
  1845 0D10 20 7D 0D		        JSR     DIR_OPEN    ; open with dir request
  1846 0D13 C0 01		        CPY     #$01        ; success (1) ?
  1847 0D15 F0 03		        BEQ     DIR_LOOP    ; if success, jump ahead
  1848 0D17 4C A4 0A		        JMP     PRINT_ERROR ; exit
  1849
  1850 0D1A			DIR_LOOP:
  1851
  1852 				    ;---------------------------------------
  1853 				    ; Send Status request to SIO
  1854 				    ;---------------------------------------
  1855 0D1A A9 48		        LDA     #<STADCB
  1856 0D1C A0 09		        LDY     #>STADCB
  1857 0D1E 20 A5 07		        JSR     DOSIOV
  1858
  1859 				    ;---------------------------------------
  1860 				    ; Status returns DVSTAT
  1861 				    ;---------------------------------------
  1862 0D21 A2 00		        LDX     #$00
  1863 0D23 EC EB 02		        CPX     DVSTAT+1    ; if byte count < 255 (that is, hi=0)
  1864 0D26 F0 09		        BEQ     DIR_LT_255  ; then skip
  1865
  1866 				    ;---------------------------------------
  1867 				    ; Branch 1: Read 255 bytes (max)
  1868 				    ;---------------------------------------
  1869 0D28 CA			        DEX                 ; X now 255 (Read FF Bytes)
  1870 0D29 8E 69 0D		        STX     DIRRDCB+8   ; DBYTL
  1871 0D2C 8E 6B 0D		        STX     DIRRDCB+10  ; DAUX1
  1872 0D2F 30 0B		        BMI     DIR_NEXT1   ; "always" true. skip down SIO call
  1873
  1874 				    ;---------------------------------------
  1875 				    ; Branch 2: Read < 255 bytes
  1876 				    ;---------------------------------------
  1877 0D31			DIR_LT_255:
  1878 0D31 AD EA 02		        LDA     DVSTAT      ; Get count of bytes remaining
  1879 0D34 F0 6C		        BEQ     DIR_ERROR   ; If here then DVSTAT = $0000 (error)
  1880 0D36 8D 69 0D		        STA     DIRRDCB+8   ; DBYTL
  1881 0D39 8D 6B 0D		        STA     DIRRDCB+10  ; DAUX1
  1882
  1883 				    ;-------------------------
  1884 				    ; Send Read request to SIO
  1885 				    ;-------------------------
  1886 0D3C			DIR_NEXT1:
  1887 0D3C A9 61		        LDA     #<DIRRDCB
  1888 0D3E A0 0D		        LDY     #>DIRRDCB
  1889 0D40 20 A5 07		        JSR     DOSIOV      ; Fetch directory listing
  1890 0D43 20 D2 0D		        JSR     DIR_PRINT   ; xfer payload to screen
  1891
  1892 				    ;---------------------------------------
  1893 				    ; Pause output if SPACE key code found
  1894 				    ;---------------------------------------
  1895 0D46			DIR_WAIT:
  1896 0D46 AD FC 02		        LDA     CH
  1897 0D49 C9 21		        CMP     #SPC_KEY
  1898 0D4B F0 F9		        BEQ     DIR_WAIT
  1899
  1900 				    ;---------------------------------------
  1901 				    ; Exit loop if ESC key code found
  1902 				    ;---------------------------------------
  1903 0D4D AD FC 02		        LDA     CH
  1904 0D50 C9 1C		        CMP     #ESC_KEY    ; hardware code for ESC key
  1905 0D52 F0 05		        BEQ     DIR_NEXT
  1906
  1907 				    ;---------------------------------------
  1908 				    ; Loop if more data to read
  1909 				    ;---------------------------------------
  1910 0D54 AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  1911 0D57 D0 C1		        BNE     DIR_LOOP    ; If yes, then do it again
  1912
  1913 0D59			DIR_NEXT:
  1914 0D59 A9 FF		        LDA     #$FF        ; Clear key
  1915 0D5B 8D FC 02		        STA     CH
  1916 0D5E 4C F0 0D		        JMP     DIR_CLOSE
  1917
  1918 0D61			DIRRDCB:
  1919 0D61 71			        .BYTE   DEVIDN      ; DDEVIC
  1920 0D62 FF			        .BYTE   $FF         ; DUNIT
  1921 0D63 52			        .BYTE   'R'         ; DCOMND
  1922 0D64 40			        .BYTE   $40         ; DSTATS
  1923 0D65 00			        .BYTE   <RBUF       ; DBUFL
  1924 0D66 18			        .BYTE   >RBUF       ; DBUFH
  1925 0D67 1F			        .BYTE   $1F         ; DTIMLO
  1926 0D68 00			        .BYTE   $00         ; DRESVD
  1927 0D69 00			        .BYTE   $00         ; DBYTL
  1928 0D6A 00			        .BYTE   $00         ; DBYTH
  1929 0D6B 00			        .BYTE   $00         ; DAUX1
  1930 0D6C 00			        .BYTE   $00         ; DAUX2
  1931
  1932 				;---------------------------------------
  1933 				; Set DUNITs in all DCBs used by DIR
  1934 				;---------------------------------------
  1935 0D6D			DIR_INIT:
  1936 				;---------------------------------------
  1937 0D6D 20 7D 0C		        JSR     GET_DOSDR   ; On return, X <- n in Nn:
  1938 0D70 8E C7 0D		        STX     DIRODCB+1   ; DUNIT for Open
  1939 0D73 8E 49 09		        STX     STADCB+1    ; DUNIT for Status
  1940 0D76 8E 62 0D		        STX     DIRRDCB+1   ; DUNIT for Read
  1941 0D79 8E 22 08		        STX     CLODCB+1    ; DUNIT for Close
  1942 0D7C 60			        RTS
  1943
  1944 				;---------------------------------------
  1945 0D7D			DIR_OPEN:
  1946 				;---------------------------------------
  1947 0D7D 20 C4 15		        JSR     PREPEND_DRIVE
  1948
  1949 				    ;-----------------------------------
  1950 				    ; Default to arg1
  1951 				    ;-----------------------------------
  1952 0D80 A6 F3		        LDX     INBUFF
  1953 0D82 A4 F4		        LDY     INBUFF+1
  1954
  1955 				    ;-----------------------------------
  1956 				    ; But use Nn:*.* if no arg1
  1957 				    ;-----------------------------------
  1958 0D84 AD 9A 0B		        LDA     CMDSEP          ; 0 means no arg1
  1959 0D87 D0 0C		        BNE     DIR_OPEN_NEXT   ; If arg1 present then skip
  1960
  1961 				    ;-----------------------------------
  1962 				    ; Here if no arg1
  1963 				    ;-----------------------------------
  1964 0D89 A2 BF		        LDX     #<DIR_OPEN_STR
  1965 0D8B A0 0D		        LDY     #>DIR_OPEN_STR
  1966
  1967 0D8D AD 75 17		        LDA     DOSDR
  1968 0D90 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  1969 0D92 8D C0 0D		        STA     DIR_OPEN_STR+1  ; Inject DOSDR into string
  1970
  1971 0D95			DIR_OPEN_NEXT:
  1972 0D95 8E CA 0D		        STX     DIRODCB+4       ; DBUFL
  1973 0D98 8C CB 0D		        STY     DIRODCB+5       ; DBUFH
  1974
  1975 0D9B A9 C6		        LDA     #<DIRODCB
  1976 0D9D A0 0D		        LDY     #>DIRODCB
  1977 0D9F 4C A5 07		        JMP     DOSIOV
  1978
  1979 				;---------------------------------------
  1980 0DA2			DIR_ERROR:
  1981 				;---------------------------------------
  1982 0DA2 A9 AC		        LDA     #<DIR_ERROR_STR
  1983 0DA4 A0 0D		        LDY     #>DIR_ERROR_STR
  1984 0DA6 20 89 0A		        JSR     PRINT_STRING
  1985 0DA9 A0 01		        LDY     #$01            ; Return error
  1986 0DAB 60			        RTS
  1987
  1988 0DAC			DIR_ERROR_STR:
  1989 0DAC 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO READ DIR',EOL
  1990
  1991 0DBF			DIR_OPEN_STR:
  1992 0DBF 4E 20 3A 2A 2E 2A +         .BYTE   'N :*.*',EOL
  1993
  1994 0DC6			DIRODCB:
  1995 0DC6 71			        .BYTE   DEVIDN          ; DDEVIC
  1996 0DC7 FF			        .BYTE   $FF             ; DUNIT
  1997 0DC8 4F			        .BYTE   'O'             ; DCOMND
  1998 0DC9 80			        .BYTE   $80             ; DSTATS
  1999 0DCA FF			        .BYTE   $FF             ; DBUFL
  2000 0DCB FF			        .BYTE   $FF             ; DBUFH
  2001 0DCC 1F			        .BYTE   $1F             ; DTIMLO
  2002 0DCD 00			        .BYTE   $00             ; DRESVD
  2003 0DCE 00			        .BYTE   $00             ; DBYTL
  2004 0DCF 01			        .BYTE   $01             ; DBYTH
  2005 0DD0 06			        .BYTE   $06             ; DAUX1
  2006 0DD1 80			        .BYTE   $80             ; DAUX2 (Long Dir)
  2007
  2008 				; End of DIR_OPEN
  2009 				;---------------------------------------
  2010
  2011 				;---------------------------------------
  2012 0DD2			DIR_PRINT:
  2013 				;---------------------------------------
  2014 				        ; Print results using CIO
  2015 0DD2 A2 00		        LDX     #$00
  2016 0DD4 A9 0B		        LDA     #PUTCHR
  2017 0DD6 9D 42 03		        STA     ICCOM,X
  2018
  2019 				        ; Fill out buffer loc
  2020 0DD9 A9 00		        LDA     #<RBUF
  2021 0DDB 9D 44 03		        STA     ICBAL,X
  2022 0DDE A9 18		        LDA     #>RBUF
  2023 0DE0 9D 45 03		        STA     ICBAH,X
  2024
  2025 				        ; Fill out size loc
  2026 0DE3 AD 69 0D		        LDA     DIRRDCB+8
  2027 0DE6 9D 48 03		        STA     ICBLL,X
  2028 0DE9 8A			        TXA
  2029 0DEA 9D 49 03		        STA     ICBLH,X
  2030 0DED 4C 56 E4		        JMP     CIOV
  2031
  2032 				;---------------------------------------
  2033 0DF0			DIR_CLOSE:
  2034 				;---------------------------------------
  2035 				        ; Close
  2036 0DF0 A9 21		        LDA     #<CLODCB
  2037 0DF2 A0 08		        LDY     #>CLODCB
  2038 0DF4 4C A5 07		        JMP     DOSIOV
  2039
  2040 				;---------------------------------------
  2041 0DF7			DO_LOAD:
  2042 				;---------------------------------------
  2043 				    ; Binary Loader based on work by Richard J. Kalagher 07-AUG-1983
  2044
  2045 				    ; Open file
  2046 0DF7 AD 9A 0B		        LDA     CMDSEP          ; Quit if no arg1
  2047 0DFA D0 03		        BNE     LOAD_NEXT1
  2048 0DFC 4C 8E 10		        JMP     LOAD_ERROR
  2049
  2050 0DFF			LOAD_NEXT1:
  2051 				    ; Point INBUFF to start of filename
  2052 0DFF 18			        CLC
  2053 0E00 65 F3		        ADC     INBUFF          ; [A] contains offset to arg1
  2054 0E02 85 F3		        STA     INBUFF
  2055 0E04 90 02		        BCC     LOAD_NEXT2
  2056 0E06 E6 F4		        INC     INBUFF+1
  2057
  2058 0E08			LOAD_NEXT2:
  2059 0E08 20 9E 0E		        JSR     LOAD_NTRANS     ; Disable any EOL translation
  2060 0E0B 20 57 0E		        JSR     LOAD_SETUP      ; Set up run and init to RTS
  2061 0E0E A9 04		        LDA     #OINPUT         ; A arg needed in LOAD_OPEN
  2062 0E10 20 6D 0E		        JSR     LOAD_OPEN       ; Open the file
  2063 0E13 C0 01		        CPY     #$01            ; Quit if unable to open
  2064 0E15 D0 3F		        BNE     R
  2065
  2066 0E17 A9 FF		        LDA     #$FF
  2067 0E19 8D 90 18		        STA     BIN_1ST
  2068 0E1C 20 AC 0E		        JSR     LOAD_READ2
  2069 0E1F 20 CD 0E		        JSR     LOAD_CHKFF
  2070 0E22 C0 01		        CPY     #$01
  2071 0E24 D0 30		        BNE     R
  2072
  2073 0E26 EE 90 18		        INC     BIN_1ST
  2074 				    ; Process each payload
  2075 0E29 20 AC 0E		GETFIL: JSR     LOAD_READ2      ; Get two bytes (binary header)
  2076 0E2C 30 28		        BMI     R               ; Exit if EOF hit
  2077 0E2E 20 62 0E		        JSR     LOAD_INIT       ; Set init default
  2078 0E31 A2 01		        LDX     #$01
  2079 0E33 20 CD 0E		        JSR     LOAD_CHKFF      ; Check if header (and start addr, too)
  2080 0E36 20 04 0F		        JSR     LOAD_STRAD      ; Put start address in
  2081 0E39 20 AC 0E		        JSR     LOAD_READ2      ; Get to more butes (end addr)
  2082 0E3C 20 11 0F		        JSR     LOAD_ENDAD      ; Put end address in
  2083 0E3F 20 2A 0F		        JSR     LOAD_BUFLEN     ; Calculate buffer length
  2084 0E42 20 4F 0F		        JSR     LOAD_GETDAT     ; Get the data record
  2085 0E45 10 03		        BPL     @+              ; Was EOF detected?
  2086 0E47 20 53 0E		        JSR     JSTART          ; Yes. Go to RUNAD
  2087 0E4A 20 50 0E		@:      JSR     JINIT           ; Attempt initialization
  2088 0E4D 4C 29 0E		        JMP     GETFIL          ; Process next payload
  2089
  2090 0E50 6C E2 02		JINIT:  JMP     (INITAD)        ; Will either RTS or perform INIT
  2091 0E53 6C E0 02		JSTART: JMP     (RUNAD)         ; Godspeed.
  2092 0E56 60			R:      RTS                     ; Stunt-double for (INITAD),(RUNAD)
  2093
  2094 				;---------------------------------------
  2095 0E57			LOAD_SETUP:
  2096 				;---------------------------------------
  2097 0E57 A9 56		        LDA     #<R
  2098 0E59 8D E0 02		        STA     RUNAD
  2099 0E5C A9 0E		        LDA     #>R
  2100 0E5E 8D E1 02		        STA     RUNAD+1
  2101 0E61 60			        RTS
  2102
  2103 				;---------------------------------------
  2104 0E62			LOAD_INIT:
  2105 				;---------------------------------------
  2106 0E62 A9 56		        LDA     #<R
  2107 0E64 8D E2 02		        STA     INITAD
  2108 0E67 A9 0E		        LDA     #>R
  2109 0E69 8D E3 02		        STA     INITAD+1
  2110 0E6C 60			        RTS
  2111
  2112 				;---------------------------------------
  2113 0E6D			LOAD_OPEN:
  2114 				;---------------------------------------
  2115 0E6D 48			        PHA                     ; Save data direction passed in A
  2116 0E6E 20 7D 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2117 0E71 8E 01 08		        STX     OPNDCB+1        ; Set DUNIT
  2118 0E74 8E 83 08		        STX     GETDCB+1        ; Set DUNIT FOR READ
  2119 0E77 20 C4 15		        JSR     PREPEND_DRIVE
  2120
  2121 0E7A A5 F3		        LDA     INBUFF          ; Register location of filename
  2122 0E7C 8D 04 08		        STA     OPNDCB+4
  2123 0E7F A5 F4		        LDA     INBUFF+1
  2124 0E81 8D 05 08		        STA     OPNDCB+5
  2125
  2126 0E84 68			        PLA                     ; A = data direction (4=in, 8=out)
  2127 0E85 8D 0A 08		        STA     OPNDCB+10
  2128 0E88 A9 00		        LDA     #$00            ; AUX2: No translation
  2129 0E8A 8D 0B 08		        STA     OPNDCB+11
  2130
  2131 0E8D A9 00		        LDA     #<OPNDCB
  2132 0E8F A0 08		        LDY     #>OPNDCB
  2133 0E91 20 A5 07		        JSR     DOSIOV
  2134
  2135 0E94 48			        PHA
  2136 0E95 20 A4 0A		        JSR     PRINT_ERROR
  2137 0E98 68			        PLA
  2138 0E99 A8			        TAY
  2139
  2140 0E9A 20 53 0A		        JSR     DIPRCD
  2141 0E9D 60			        RTS
  2142
  2143 				;---------------------------------------
  2144 0E9E			LOAD_NTRANS:
  2145 				;---------------------------------------
  2146 				    ; Disable any EOL transation otherwise
  2147 				    ; binary data will be corrupted during load
  2148 				    ;---------------------------------------
  2149 0E9E 20 7D 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2150 0EA1 8E 87 11		        STX     NTRDCB+1        ; Set DUNIT
  2151 0EA4 A9 00		        LDA     #$00
  2152 0EA6 8D 91 11		        STA     NTRDCB+11       ; Translation mode (0 = NONE)
  2153 0EA9 4C 53 11		        JMP     NTRANS_CALL     ; Reuse code in DO_NTRANS
  2154
  2155 				;---------------------------------------
  2156 0EAC			LOAD_READ2:
  2157 				;---------------------------------------
  2158 				    ; Load 2 bytes into Buffer (BAL/H).
  2159 				    ;---------------------------------------
  2160 				    ; This is accomplished by abusing the LOAD_GETDAT
  2161 				    ; routine by stuffing the buffer addr (BAL/H)
  2162 				    ; into the payload Start/End addrs. We're doing
  2163 				    ; this in case a payload  header straddles a
  2164 				    ; cache boundary. LOAD_GETDAT has the logic for
  2165 				    ; dealing with that.
  2166 				    ;---------------------------------------
  2167 0EAC A9 00		        LDA     #<BAL
  2168 0EAE 8D 80 18		        STA     STL             ; Payload start address
  2169 0EB1 A9 18		        LDA     #>BAL
  2170 0EB3 8D 81 18		        STA     STH
  2171
  2172 0EB6 A9 01		        LDA     #<BAH
  2173 0EB8 8D 82 18		        STA     ENL             ; Payload end address
  2174 0EBB A9 18		        LDA     #>BAH
  2175 0EBD 8D 83 18		        STA     ENH
  2176
  2177 0EC0 A2 02		        LDX     #$02
  2178 0EC2 8E 84 18		        STX     BLL             ; Payload size (2)
  2179 0EC5 A9 00		        LDA     #$00
  2180 0EC7 8D 85 18		        STA     BLH
  2181
  2182 0ECA 4C 4F 0F		        JMP     LOAD_GETDAT     ; Read 2 bytes
  2183
  2184 				;---------------------------------------
  2185 0ECD			LOAD_CHKFF:
  2186 				;---------------------------------------
  2187 				    ; On 1st pass, check for binary signature (FF FF)
  2188 				    ; On 2..n passes, Skip FF FF (if found) 
  2189 				    ; and read next 2 bytes
  2190 				    ;---------------------------------------
  2191 				        
  2192 0ECD A9 FF		        LDA     #$FF
  2193 0ECF CD 00 18		        CMP     BAL         ; Is 1st byte FF?
  2194 0ED2 D0 0D		        BNE     NOTFF       ; If no, skip down.
  2195 0ED4 CD 01 18		        CMP     BAH         ; Is 2nd byte FF?
  2196 0ED7 D0 08		        BNE     NOTFF       ; If no, skip down.
  2197
  2198 				    ;---------------------------------------
  2199 				    ; Here if FF FF tags found. 
  2200 				    ; On 1st pass, we're done.
  2201 				    ; On 2..n passes, read next 2 bytes and leave.
  2202 				    ;---------------------------------------
  2203 0ED9 CD 90 18		        CMP     BIN_1ST     ; Is this 1st pass?
  2204 0EDC F0 13		        BEQ     NOTFF_DONE  ; If yes, then we're done here.
  2205 0EDE 4C AC 0E		        JMP     LOAD_READ2  ; 
  2206
  2207 				    ;---------------------------------------
  2208 				    ; Here if FF FF tags NOT found. 
  2209 				    ; On 1st pass, print error.
  2210 				    ; On 2..n passes, the 2 bytes = payload start addr.
  2211 				    ;---------------------------------------
  2212 0EE1 A0 01		NOTFF:  LDY     #$01        ; Preload success return code
  2213 0EE3 CD 90 18		        CMP     BIN_1ST     ; A still has FF. BIN_1ST = FF on first pass
  2214 0EE6 D0 09		        BNE     NOTFF_DONE  ; Not 1st pass, exit with success.
  2215
  2216 0EE8			NOTFF_ERR:
  2217 0EE8 A9 F2		        LDA     #<LOAD_ERROR_STR2
  2218 0EEA A0 0E		        LDY     #>LOAD_ERROR_STR2
  2219 0EEC 20 89 0A		        JSR     PRINT_STRING
  2220
  2221 0EEF A0 FF		        LDY     #$FF        ; Return failure
  2222 0EF1			NOTFF_DONE:
  2223 0EF1 60			        RTS
  2224
  2225 0EF2			LOAD_ERROR_STR2:
  2226 0EF2 4E 4F 54 20 41 20 +         .BYTE   'NOT A BINARY FILE',EOL
  2227
  2228 				;---------------------------------------
  2229 0F04			LOAD_STRAD:
  2230 				;---------------------------------------
  2231 				    ; Save payload start address into STL2/STLH2.
  2232 				    ; Otherwise it will get clobbered
  2233 				    ; when reading payload end address.
  2234 0F04 AD 00 18		        LDA     RBUF
  2235 0F07 8D 8E 18		        STA     STL2
  2236 0F0A AD 01 18		        LDA     RBUF+1
  2237 0F0D 8D 8F 18		        STA     STH2
  2238 0F10 60			        RTS
  2239
  2240 				;---------------------------------------
  2241 0F11			LOAD_ENDAD:
  2242 				;---------------------------------------
  2243 				    ; Save payload end address
  2244 0F11 AD 8E 18		        LDA     STL2
  2245 0F14 8D 80 18		        STA     STL
  2246 0F17 AD 8F 18		        LDA     STH2
  2247 0F1A 8D 81 18		        STA     STH
  2248 				    
  2249 0F1D AD 00 18		        LDA     RBUF
  2250 0F20 8D 82 18		        STA     ENL
  2251 0F23 AD 01 18		        LDA     RBUF+1
  2252 0F26 8D 83 18		        STA     ENH
  2253 0F29 60			        RTS
  2254
  2255 				;---------------------------------------
  2256 0F2A			LOAD_BUFLEN:
  2257 				;---------------------------------------
  2258 				    ; Calculate buffer length (end-start+1)
  2259
  2260 				    ; Calc buffer size Lo
  2261 0F2A AD 82 18		        LDA     ENL
  2262 0F2D 38			        SEC
  2263 0F2E ED 80 18		        SBC     STL
  2264 0F31 8D 84 18		        STA     BLL     ; Buffer Length Lo
  2265
  2266 				    ; Calc buffer size Hi
  2267 0F34 AD 83 18		        LDA     ENH     ; Calc buffer size Hi
  2268 0F37 ED 81 18		        SBC     STH
  2269 0F3A 8D 85 18		        STA     BLH     ; Buffer Length Hi
  2270
  2271 				    ; Add 1
  2272 0F3D 18			        CLC
  2273 0F3E AD 84 18		        LDA     BLL
  2274 0F41 69 01		        ADC     #$01
  2275 0F43 8D 84 18		        STA     BLL
  2276
  2277 0F46 AD 85 18		        LDA     BLH
  2278 0F49 69 00		        ADC     #$00    ; Take care of any carry
  2279 0F4B 8D 85 18		        STA     BLH
  2280
  2281 0F4E 60			        RTS
  2282
  2283 				;;---------------------------------------
  2284 				;LOAD_GETDAT:
  2285 				;;---------------------------------------
  2286 				;
  2287 				;    ;---------------------------------------
  2288 				;    ; Fill out the DCB
  2289 				;    ;---------------------------------------
  2290 				;        JSR     GET_DOSDR
  2291 				;        STX     BINDCB+1        ; DUNIT
  2292 				;
  2293 				;        LDA     STL
  2294 				;        STA     BINDCB+4        ; DBUFL 
  2295 				;        LDA     STH
  2296 				;        STA     BINDCB+5        ; DBUFH
  2297 				;        LDA     BLL
  2298 				;        STA     BINDCB+8        ; DBYTL
  2299 				;        STA     BINDCB+10
  2300 				;        LDA     BLH
  2301 				;        STA     BINDCB+9        ; DBYTH
  2302 				;        STA     BINDCB+11
  2303 				;
  2304 				;    ;---------------------------------------
  2305 				;    ; Send Read request to SIO
  2306 				;    ;---------------------------------------
  2307 				;        LDA     #<BINDCB
  2308 				;        LDY     #>BINDCB
  2309 				;        JSR     DOSIOV
  2310 				;        JSR     PRINT_ERROR     ; Show any errors
  2311 				;
  2312 				;    ;---------------------------------------
  2313 				;    ; Get status (updates DVSTAT, DSTATS)
  2314 				;    ;---------------------------------------
  2315 				;        LDA     BINDCB+1
  2316 				;        STA     STADCB+1
  2317 				;        LDA     #<STADCB
  2318 				;        LDY     #>STADCB
  2319 				;        JSR     DOSIOV
  2320 				;
  2321 				;    ; Check if EOF (current requested chunk completed?)
  2322 				;        LDA     #EOF
  2323 				;        CMP     DVSTAT+3
  2324 				;        BEQ     LOAD_GETDAT_DONE
  2325 				;        JMP     PRINT_ERROR
  2326 				;
  2327 				;LOAD_GETDAT_DONE:
  2328 				;    ; Check if 0 bytes remaining
  2329 				;        LDA     DVSTAT
  2330 				;        BNE     LOAD_GETDAT_DONE2
  2331 				;        LDA     DVSTAT+1
  2332 				;        BNE     LOAD_GETDAT_DONE2
  2333 				;        LDY     #$FF
  2334 				;        RTS
  2335 				;
  2336 				;LOAD_GETDAT_DONE2:
  2337 				;        LDY     #$01            ; Return success
  2338 				;        RTS
  2339 				;        
  2340 				;BINDCB:
  2341 				;       .BYTE    DEVIDN      ; DDEVIC
  2342 				;       .BYTE    $FF         ; DUNIT
  2343 				;       .BYTE    'R'         ; DCOMND
  2344 				;       .BYTE    $40         ; DSTATS
  2345 				;       .BYTE    $FF         ; DBUFL
  2346 				;       .BYTE    $FF         ; DBUFH
  2347 				;       .BYTE    $0F         ; DTIMLO
  2348 				;       .BYTE    $00         ; DRESVD
  2349 				;       .BYTE    $FF         ; DBYTL
  2350 				;       .BYTE    $FF         ; DBYTH
  2351 				;       .BYTE    $FF         ; DAUX1
  2352 				;       .BYTE    $FF         ; DAUX2
  2353
  2354 				;---------------------------------------
  2355 0F4F			LOAD_GETDAT:
  2356 				;---------------------------------------
  2357 				    ; Definitions:
  2358 				    ; HEAD = requested bytes that will be found in current cache (< 512 bytes)
  2359 				    ; BODY = contiguous 512 byte sections. BODY = n * 512 bytes)
  2360 				    ; TAIL = any bytes remaining after BODY (< 512 bytes)
  2361
  2362 0F4F 20 7D 0C		        JSR     GET_DOSDR
  2363 0F52 8E 76 10		        STX     BINDCB+1
  2364
  2365 0F55 20 51 10		        JSR     GETDAT_CHECK_EOF    ; Check EOF before proceeding
  2366 0F58 10 01		        BPL     GETDAT_NEXT1        ; If true, then EOF found. Exit
  2367 0F5A 60			        RTS
  2368
  2369 				    ; Check if bytes requested BL < DVSTAT (bytes waiting in cache)
  2370 0F5B			GETDAT_NEXT1:
  2371 0F5B AD EA 02		        LDA     DVSTAT
  2372 0F5E CD 84 18		        CMP     BLL
  2373 0F61 AD EB 02		        LDA     DVSTAT+1
  2374 0F64 ED 85 18		        SBC     BLH
  2375 0F67 B0 4C		        BCS     GETDAT_OPT2     ; BL <= BW (bytes waiting)
  2376
  2377 0F69			GETDAT_OPT1:
  2378 				    ;--------------------------------
  2379 				    ; Here if bytes requested > bytes 
  2380 				    ; remaining in cache
  2381 				    ;------------------------P--------
  2382
  2383 				    ;-------------------------------
  2384 				    ; Head = BW (bytes waiting)
  2385 				    ;-------------------------------
  2386 0F69 AD EA 02		        LDA     DVSTAT
  2387 0F6C 8D 86 18		        STA     HEADL
  2388 0F6F AD EB 02		        LDA     DVSTAT+1
  2389 0F72 8D 87 18		        STA     HEADH
  2390
  2391 				    ;-------------------------------
  2392 				    ; Tail = (BL - HEAD) mod 512
  2393 				    ;-------------------------------
  2394 0F75 38			        SEC
  2395 0F76 AD 84 18		        LDA     BLL
  2396 0F79 ED 86 18		        SBC     HEADL
  2397 0F7C 29 FF		        AND     #$FF
  2398 0F7E 8D 8A 18		        STA     TAILL
  2399 0F81 AD 85 18		        LDA     BLH
  2400 0F84 ED 87 18		        SBC     HEADH
  2401 0F87 29 01		        AND     #$01
  2402 0F89 8D 8B 18		        STA     TAILH
  2403
  2404 				    ;-----------------------------------
  2405 				    ; Body = BL - HEAD - TAIL
  2406 				    ;-----------------------------------
  2407 				        ; 1. Body = BL - HEAD
  2408 				        ;-------------------------------
  2409 0F8C 38			        SEC
  2410 0F8D AD 84 18		        LDA     BLL
  2411 0F90 ED 86 18		        SBC     HEADL
  2412 0F93 8D 88 18		        STA     BODYL
  2413 0F96 AD 85 18		        LDA     BLH
  2414 0F99 ED 87 18		        SBC     HEADH
  2415 0F9C 8D 89 18		        STA     BODYH
  2416
  2417 				        ;-------------------------------
  2418 				        ; 2. Body = Body - HEAD
  2419 				        ;-------------------------------
  2420 0F9F 38			        SEC
  2421 0FA0 AD 88 18		        LDA     BODYL
  2422 0FA3 ED 8A 18		        SBC     TAILL
  2423 0FA6 8D 88 18		        STA     BODYL
  2424 0FA9 AD 89 18		        LDA     BODYH
  2425 0FAC ED 8B 18		        SBC     TAILH
  2426 0FAF 8D 89 18		        STA     BODYH
  2427
  2428 0FB2 4C CF 0F		        JMP     GETDAT_READ
  2429
  2430 0FB5			GETDAT_OPT2:
  2431 				    ;--------------------------------
  2432 				    ; Here if bytes requested <= bytes 
  2433 				    ; remaining in cache
  2434 				    ;--------------------------------
  2435 				    ; Head = BL, TAIL = BODY = 0
  2436 				    ;--------------------------------
  2437 0FB5 AD 84 18		        LDA     BLL
  2438 0FB8 8D 86 18		        STA     HEADL
  2439 0FBB AD 85 18		        LDA     BLH
  2440 0FBE 8D 87 18		        STA     HEADH
  2441 0FC1 A9 00		        LDA     #$00
  2442 0FC3 8D 8A 18		        STA     TAILL
  2443 0FC6 8D 8B 18		        STA     TAILH
  2444 0FC9 8D 88 18		        STA     BODYL
  2445 0FCC 8D 89 18		        STA     BODYH
  2446
  2447 				;---------------------------------------
  2448 0FCF			GETDAT_READ:
  2449 				;---------------------------------------
  2450 				    ;---------------------------------------
  2451 				    ; Read HEAD bytes
  2452 				    ;---------------------------------------
  2453 0FCF AD 86 18		        LDA     HEADL
  2454 0FD2 8D 84 18		        STA     BLL
  2455 0FD5 AD 87 18		        LDA     HEADH
  2456 0FD8 8D 85 18		        STA     BLH
  2457 0FDB 20 0C 10		        JSR     GETDAT_DOSIOV
  2458 0FDE 10 01		        BPL     GETDAT_BODY ; Skip ahead if no problems
  2459 0FE0 60			        RTS                 ; Bail if error
  2460
  2461 				    ;---------------------------------------
  2462 				    ; Read BODY bytes
  2463 				    ;---------------------------------------
  2464 0FE1			GETDAT_BODY:
  2465 0FE1 AE 89 18		        LDX     BODYH
  2466 0FE4			GETDAT_BODY_LOOP:
  2467 0FE4 F0 1A		        BEQ     GETDAT_TAIL ; Skip if less than a page to read
  2468
  2469 0FE6 A9 00		        LDA     #$00
  2470 0FE8 8D 84 18		        STA     BLL         ; Buffer length
  2471 0FEB A9 02		        LDA     #$02        ; 512 bytes at a time
  2472 0FED 8D 85 18		        STA     BLH
  2473
  2474 0FF0 8A			        TXA                 ; Stash our loop index (X)
  2475 0FF1 48			        PHA                 ; onto the stack
  2476 0FF2 20 0C 10		        JSR     GETDAT_DOSIOV   
  2477 0FF5 10 03		        BPL     @+          ; Skip ahead if no problems
  2478 0FF7 68			        PLA                 ; Here if problem. Clean up stack
  2479 0FF8 98			        TYA                 ; Reset N status flag before returning
  2480 0FF9 60			        RTS                 ; Bail if error
  2481
  2482 0FFA 68			@:      PLA                 ; Retrieve our loop index
  2483 0FFB AA			        TAX                 ; and xfer it back into X
  2484 0FFC CA			        DEX                 ; -2 (we pull 0200 bytes at a time)
  2485 0FFD CA			        DEX                 ; 
  2486 0FFE D0 E4		        BNE     GETDAT_BODY_LOOP
  2487
  2488 1000			GETDAT_TAIL:
  2489 				    ;---------------------------------------
  2490 				    ; Read TAIL bytes
  2491 				    ;---------------------------------------
  2492 1000 AD 8A 18		        LDA     TAILL
  2493 1003 8D 84 18		        STA     BLL
  2494 1006 AD 8B 18		        LDA     TAILH
  2495 1009 8D 85 18		        STA     BLH
  2496
  2497 				;---------------------------------------
  2498 100C			GETDAT_DOSIOV:
  2499 				;---------------------------------------
  2500 				    ; Bail if BL = 0
  2501 100C AD 84 18		        LDA     BLL
  2502 100F D0 05		        BNE     @+
  2503 1011 AD 85 18		        LDA     BLH
  2504 1014 F0 5C		        BEQ     CHECK_EOF_DONE
  2505
  2506 1016			@:
  2507 				    ; SIO READ
  2508 1016 AD 80 18		        LDA     STL
  2509 1019 8D 79 10		        STA     BINDCB+4    ; Start Address Lo
  2510 101C AD 81 18		        LDA     STH
  2511 101F 8D 7A 10		        STA     BINDCB+5    ; Start Address Hi
  2512 1022 AD 84 18		        LDA     BLL
  2513 1025 8D 7D 10		        STA     BINDCB+8    ; Buffer Size Lo
  2514 1028 8D 7F 10		        STA     BINDCB+10
  2515 102B AD 85 18		        LDA     BLH
  2516 102E 8D 7E 10		        STA     BINDCB+9    ; Buffer Size Hi
  2517 1031 8D 80 10		        STA     BINDCB+11
  2518
  2519 				    ;---------------------------------------
  2520 				    ; Send Read request to SIO
  2521 				    ;---------------------------------------
  2522 1034 A9 75		        LDA     #<BINDCB
  2523 1036 A0 10		        LDY     #>BINDCB
  2524 1038 20 A5 07		        JSR     DOSIOV
  2525 103B 20 A4 0A		        JSR     PRINT_ERROR
  2526
  2527 				    ;---------------------------------------
  2528 				    ; Advance start address by buffer length
  2529 				    ;---------------------------------------
  2530 103E 18			        CLC
  2531 103F AD 80 18		        LDA     STL
  2532 1042 6D 84 18		        ADC     BLL
  2533 1045 8D 80 18		        STA     STL
  2534
  2535 1048 AD 81 18		        LDA     STH
  2536 104B 6D 85 18		        ADC     BLH
  2537 104E 8D 81 18		        STA     STH
  2538
  2539 1051			GETDAT_CHECK_EOF:
  2540 				    ; Get status (updates DVSTAT, DSTATS)
  2541 1051 AD 76 10		        LDA     BINDCB+1
  2542 1054 8D 49 09		        STA     STADCB+1
  2543 1057 A9 48		        LDA     #<STADCB
  2544 1059 A0 09		        LDY     #>STADCB
  2545 105B 20 A5 07		        JSR     DOSIOV
  2546
  2547 				    ; Return -1 if DVSTAT == $0000 and DVSTAT+3 == EOF
  2548 105E AD EA 02		        LDA     DVSTAT
  2549 1061 D0 0F		        BNE     CHECK_EOF_DONE
  2550
  2551 1063 AD EB 02		        LDA     DVSTAT+1
  2552 1066 D0 0A		        BNE     CHECK_EOF_DONE
  2553
  2554 1068 A9 88		        LDA     #EOF
  2555 106A CD ED 02		        CMP     DVSTAT+3        ; Is it EOF
  2556 106D D0 03		        BNE     CHECK_EOF_DONE  ; No? Go to success
  2557 106F A0 FF		        LDY     #$FF            ; Yes? Return -1
  2558 1071 60			        RTS
  2559
  2560 1072			CHECK_EOF_DONE:
  2561 1072 A0 01		        LDY     #$01            ; Return success
  2562 1074 60			        RTS
  2563
  2564 1075			BINDCB:
  2565 1075 71			       .BYTE    DEVIDN      ; DDEVIC
  2566 1076 FF			       .BYTE    $FF         ; DUNIT
  2567 1077 52			       .BYTE    'R'         ; DCOMND
  2568 1078 40			       .BYTE    $40         ; DSTATS
  2569 1079 FF			       .BYTE    $FF         ; DBUFL
  2570 107A FF			       .BYTE    $FF         ; DBUFH
  2571 107B 0F			       .BYTE    $0F         ; DTIMLO
  2572 107C 00			       .BYTE    $00         ; DRESVD
  2573 107D FF			       .BYTE    $FF         ; DBYTL
  2574 107E FF			       .BYTE    $FF         ; DBYTH
  2575 107F FF			       .BYTE    $FF         ; DAUX1
  2576 1080 FF			       .BYTE    $FF         ; DAUX2
  2577
  2578
  2579 				;---------------------------------------
  2580 1081			LOAD_CLOSE:
  2581 				;---------------------------------------
  2582 1081 AD 76 10		        LDA     BINDCB+1
  2583 1084 8D 22 08		        STA     CLODCB+1
  2584 1087 A9 21		        LDA     #<CLODCB
  2585 1089 A0 08		        LDY     #>CLODCB
  2586 108B 4C A5 07		        JMP     DOSIOV
  2587
  2588 				;---------------------------------------
  2589 108E			LOAD_ERROR:
  2590 				;---------------------------------------
  2591 108E A9 6F		        LDA     #<MISSING_FILE_STR
  2592 1090 A0 17		        LDY     #>MISSING_FILE_STR
  2593 1092 4C 89 0A		        JMP     PRINT_STRING
  2594
  2595 				;;---------------------------------------
  2596 				;DO_LOCK:
  2597 				;;---------------------------------------
  2598 				;        LDA     #$60
  2599 				;        STA     COLOR2
  2600 				;        RTS
  2601
  2602 				;---------------------------------------
  2603 1095			DO_LOGIN:
  2604 				;---------------------------------------
  2605 1095 A9 A0		        LDA     #$A0
  2606 1097 8D C6 02		        STA     COLOR2
  2607 109A 60			        RTS
  2608
  2609 109B			LOGIN_ERROR:
  2610 109B A9 A2		        LDA     #<LOGIN_ERROR_STR
  2611 109D A0 10		        LDY     #>LOGIN_ERROR_STR
  2612 109F 4C 89 0A		        JMP     PRINT_STRING
  2613
  2614 10A2			LOGIN_ERROR_STR:
  2615 10A2 4C 4F 47 49 4E 20 +         .BYTE   'LOGIN [N[n]:] <USERNAME> <PASSWORD>',EOL
  2616
  2617 				;---------------------------------------
  2618 10C6			DO_LPR:
  2619 				;---------------------------------------
  2620 10C6 A9 B0		        LDA     #$B0
  2621 10C8 8D C6 02		        STA     COLOR2
  2622 10CB 60			        RTS
  2623
  2624 				;---------------------------------------
  2625 10CC			DO_NPWD:
  2626 				;---------------------------------------
  2627 10CC A9 9B		        LDA     #EOL        ; Truncate buffer
  2628 10CE 8D 00 18		        STA     RBUF
  2629
  2630 10D1 20 7D 0C		        JSR     GET_DOSDR   ; X will contain n in Nn:
  2631 10D4 8E 04 11		        STX     PWDDCB+1
  2632
  2633 10D7 A9 03		        LDA     #<PWDDCB
  2634 10D9 A0 11		        LDY     #>PWDDCB
  2635 10DB 20 A5 07		        JSR     DOSIOV
  2636 10DE 20 A4 0A		        JSR     PRINT_ERROR
  2637
  2638 				    ;---------------------------------------
  2639 				    ; If we entered DO_NPWD from REMOUNT_DRIVE
  2640 				    ; then scipt printing output
  2641 				    ;---------------------------------------
  2642 10E1 AD 77 17		        LDA     CMDPRV
  2643 10E4 C9 02		        CMP     #CMD_IDX.DEL
  2644 10E6 F0 1A		        BEQ     NPWD_DONE
  2645 10E8 C9 09		        CMP     #CMD_IDX.RENAME
  2646 10EA F0 16		        BEQ     NPWD_DONE
  2647
  2648 10EC			NPWD_LOOP:
  2649 10EC A9 00		        LDA     #<RBUF
  2650 10EE A0 18		        LDY     #>RBUF
  2651 10F0 20 89 0A		        JSR     PRINT_STRING
  2652
  2653 10F3 A9 48		        LDA     #<STADCB
  2654 10F5 A0 09		        LDY     #>STADCB
  2655 10F7 20 A5 07		        JSR     DOSIOV
  2656 10FA 20 A4 0A		        JSR     PRINT_ERROR
  2657
  2658 				    ;---------------------------------------
  2659 				    ; Loop if more data to read
  2660 				    ;---------------------------------------
  2661 10FD AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  2662 1100 D0 EA		        BNE     NPWD_LOOP   ; If yes, then do it again
  2663
  2664 1102			NPWD_DONE:
  2665 1102 60			        RTS
  2666
  2667 1103			PWDDCB:
  2668 1103 71			        .BYTE   DEVIDN      ; DDEVIC
  2669 1104 FF			        .BYTE   $FF         ; DUNIT
  2670 1105 30			        .BYTE   $30         ; DCOMND
  2671 1106 40			        .BYTE   $40         ; DSTATS
  2672 1107 00			        .BYTE   <RBUF       ; DBUFL
  2673 1108 18			        .BYTE   >RBUF       ; DBUFH
  2674 1109 1F			        .BYTE   $1F         ; DTIMLO
  2675 110A 00			        .BYTE   $00         ; DRESVD
  2676 110B 00			        .BYTE   $00         ; DBYTL
  2677 110C 01			        .BYTE   $01         ; DBYTH
  2678 110D 00			        .BYTE   $00         ; DAUX1
  2679 110E 00			        .BYTE   $00         ; DAUX2
  2680
  2681 				; End of DO_NPWD
  2682 				;---------------------------------------
  2683
  2684 				;---------------------------------------
  2685 110F			DO_NTRANS:
  2686 				;---------------------------------------
  2687 110F AE 9A 0B		        LDX     CMDSEP          ; Check if there's any args
  2688 1112 F0 49		        BEQ     NTRANS_ERROR    ; No. Show usage and quit
  2689
  2690 1114 AD 75 17		        LDA     DOSDR           ; Go with current drive for now
  2691 1117 8D 87 11		        STA     NTRDCB+1        ; it'll be overwritten later if req'd
  2692
  2693 				    ;---------------------------------------
  2694 				    ; Check for argc = 2
  2695 				    ;---------------------------------------
  2696 111A AC 9A 0B		        LDY     CMDSEP          ; Stash offset to arg1 in Y
  2697 111D AE 9B 0B		        LDX     CMDSEP+1        ; Is there an arg2?
  2698 1120 F0 21		        BEQ     PARSE_MODE      ; No. parse arg1 as mode (0-3)
  2699
  2700 				    ;---------------------------------------
  2701 				    ; Here if argc = 2 (arg1 = Nn: arg2 = mode)
  2702 				    ;---------------------------------------
  2703 1122 AE 9A 0B		        LDX     CMDSEP          ; Get offset to arg1 (Nn:)
  2704 1125 BD 80 18		        LDA     LNBUF,X         ; Is arg1's (N[n]:) 1st char = 'N'?
  2705 1128 C9 4E		        CMP     #'N'            ;
  2706 112A D0 31		        BNE     NTRANS_ERROR    ; No? Then quit
  2707 112C BD 81 18		        LDA     LNBUF+1,X
  2708 112F C9 3A		        CMP     #':'            ; Is arg1's (N[n]:) 2nd char = ':'?
  2709 1131 F0 10		        BEQ     PARSE_MODE      ; Yes, stick with default drive
  2710
  2711 				    ;---------------------------------------
  2712 				    ; Parse drive number
  2713 				    ;---------------------------------------
  2714 1133 C9 31		        CMP     #'1'            ; Quit if n in Nn not 1..4
  2715 1135 90 26		        BCC     NTRANS_ERROR    ; Quit if < '1'
  2716 1137 C9 39		        CMP     #'9'
  2717 1139 B0 22		        BCS     NTRANS_ERROR    ; Quit if >= '9'
  2718 113B 49 30		        EOR     #%00110000
  2719 113D 8D 87 11		        STA     NTRDCB+1
  2720 1140 AC 9B 0B		        LDY     CMDSEP+1
  2721
  2722 				    ;---------------------------------------
  2723 				    ; Confirm valid parameter
  2724 				    ;---------------------------------------
  2725 1143			PARSE_MODE:
  2726 1143 B9 80 18		        LDA     LNBUF,Y         ; Quit if mode not 0..3
  2727 1146 C9 30		        CMP     #'0'
  2728 1148 90 13		        BCC     NTRANS_ERROR
  2729 114A C9 34		        CMP     #'4'
  2730 114C B0 0F		        BCS     NTRANS_ERROR
  2731 114E 49 30		        EOR     #%00110000      ; Here if valid parameter
  2732 1150 8D 91 11		        STA     NTRDCB+11       ; Assign parameter to DCB
  2733
  2734 				    ;---------------------------------------
  2735 				    ; Call SIO
  2736 				    ;---------------------------------------
  2737 1153			NTRANS_CALL:
  2738 1153 A9 86		        LDA     #<NTRDCB
  2739 1155 A0 11		        LDY     #>NTRDCB
  2740 1157 20 A5 07		        JSR     DOSIOV
  2741 115A 4C A4 0A		        JMP     PRINT_ERROR
  2742
  2743 115D			NTRANS_ERROR:
  2744 115D A9 64		        LDA     #<NTRANS_ERROR_STR
  2745 115F A0 11		        LDY     #>NTRANS_ERROR_STR
  2746 1161 4C 89 0A		        JMP     PRINT_STRING
  2747
  2748 1164			NTRANS_ERROR_STR:
  2749 1164 4D 4F 44 45 3F 20 +         .BYTE   'MODE? 0=NONE, 1=CR, 2=LF, 3=CR/LF',EOL
  2750
  2751 1186			NTRDCB:
  2752 1186 71			        .BYTE   DEVIDN  ; DDEVIC
  2753 1187 FF			        .BYTE   $FF     ; DUNIT
  2754 1188 54			        .BYTE   'T'     ; DCOMND
  2755 1189 00			        .BYTE   $00     ; DSTATS
  2756 118A 00			        .BYTE   $00     ; DBUFL
  2757 118B 00			        .BYTE   $00     ; DBUFH
  2758 118C 1F			        .BYTE   $1F     ; DTIMLO
  2759 118D 00			        .BYTE   $00     ; DRESVD
  2760 118E 00			        .BYTE   $00     ; DBYTL
  2761 118F 00			        .BYTE   $00     ; DBYTH
  2762 1190 00			        .BYTE   $00     ; DAUX1
  2763 1191 00			        .BYTE   $00     ; DAUX2
  2764
  2765 				; End of DO_NTRANS
  2766 				;---------------------------------------
  2767
  2768 				;---------------------------------------
  2769 1192			DO_AUTORUN:
  2770 				;---------------------------------------
  2771 				    ; Change URL stored in AUTORUN app key
  2772 				    ;-----------------------------------
  2773 1192 AD 9A 0B		        LDA     CMDSEP          ; Check if there's any arg
  2774 1195 D0 07		        BNE     AUTORUN_NEXT1   ; If arg found, skip ahead
  2775
  2776 				    ; Here if no command line arg found
  2777 				    ; Print error message and exit
  2778 1197 A9 DF		        LDA     #<AUTORUN_ERROR_STR
  2779 1199 A0 11		        LDY     #>AUTORUN_ERROR_STR
  2780 119B 4C 89 0A		        JMP     PRINT_STRING
  2781
  2782 119E			AUTORUN_NEXT1:
  2783 				    ; Point to start of arg on command line
  2784 119E 18			        CLC
  2785 119F 65 F3		        ADC     INBUFF          ; INBUFF += CMDSEP
  2786 11A1 85 F3		        STA     INBUFF
  2787 11A3 8D 13 12		        STA     APPKEYWRITEDCB+4
  2788
  2789 				    ; If "AUTORUN ?" Then abuse AUTORUN_SUBMIT to print appkey
  2790 11A6 A0 00		        LDY     #$00
  2791 11A8 A9 3F		        LDA     #'?'
  2792 11AA 8D 91 18		        STA     AUTORUN_QUERY_FLG
  2793 11AD D1 F3		        CMP     (INBUFF),Y
  2794 11AF F0 6A		        BEQ     SUBMIT_AUTORUN
  2795
  2796 				    ; Open app key
  2797 11B1 A9 01		        LDA     #$01            ; Open for write (1)
  2798 11B3 8D 91 18		        STA     AUTORUN_QUERY_FLG
  2799 11B6 8D E9 11		        STA     AUTORUN_APPKEY+4
  2800 11B9 A9 F7		        LDA     #<APPKEYOPENDCB
  2801 11BB A0 11		        LDY     #>APPKEYOPENDCB
  2802 11BD 20 A5 07		        JSR     DOSIOV
  2803
  2804 				    ; Find length of URL (arg1)
  2805 11C0 A0 FF		        LDY     #$FF            ; Init strlen
  2806 11C2			AUTORUN_LOOP1
  2807 11C2 C8			        INY                     ; Incr strlen
  2808 11C3 B1 F3		        LDA     (INBUFF),Y
  2809 11C5 C9 9B		        CMP     #EOL            ; At end of string?
  2810 11C7 D0 F9		        BNE     AUTORUN_LOOP1   ; No. Keep counting
  2811
  2812 11C9 A9 0A		        LDA     #LF             ; Convert EOL to LF
  2813 11CB 91 F3		        STA     (INBUFF),Y
  2814 11CD C8			        INY                     ; One more for strlen
  2815
  2816 11CE			AUTORUN_NEXT2: 
  2817 				    ; Write app key
  2818 11CE 8C 19 12		        STY     APPKEYWRITEDCB+10   ; Y = strlen
  2819 11D1 A9 0F		        LDA     #<APPKEYWRITEDCB
  2820 11D3 A0 12		        LDY     #>APPKEYWRITEDCB
  2821 11D5 20 A5 07		        JSR     DOSIOV
  2822
  2823 				    ; Close app key
  2824 11D8 A9 EB		        LDA     #<APPKEYCLOSEDCB
  2825 11DA A0 11		        LDY     #>APPKEYCLOSEDCB
  2826 11DC 4C A5 07		        JMP     DOSIOV
  2827
  2828 11DF			AUTORUN_ERROR_STR:
  2829 11DF 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  2830
  2831 11E5			AUTORUN_APPKEY:
  2832 11E5 79 DB		        .WORD   $DB79           ; creator ID
  2833 11E7 00			        .BYTE   $00             ; app ID
  2834 11E8 00			        .BYTE   $00             ; key ID
  2835 11E9 00			        .BYTE   $00             ; read or write mode
  2836 11EA 00			        .BYTE   $00             ; unused
  2837
  2838 11EB			APPKEYCLOSEDCB:
  2839 11EB 70			        .BYTE   $70             ; DDEVIC
  2840 11EC 01			        .BYTE   $01             ; DUNIT
  2841 11ED DB			        .BYTE   $DB             ; DCOMND
  2842 11EE 00			        .BYTE   $00             ; DSTATS
  2843 11EF 00			        .BYTE   $00             ; DBUFL
  2844 11F0 00			        .BYTE   $00             ; DBUFH
  2845 11F1 0F			        .BYTE   $0F             ; DTIMLO
  2846 11F2 00			        .BYTE   $00             ; DRESVD
  2847 11F3 00			        .BYTE   $00             ; DBYTL
  2848 11F4 00			        .BYTE   $00             ; DBYTH
  2849 11F5 00			        .BYTE   $00             ; DAUX1
  2850 11F6 00			        .BYTE   $00             ; DAUX2
  2851
  2852 11F7			APPKEYOPENDCB:
  2853 11F7 70			        .BYTE   $70             ; DDEVIC
  2854 11F8 01			        .BYTE   $01             ; DUNIT
  2855 11F9 DC			        .BYTE   $DC             ; DCOMND
  2856 11FA 80			        .BYTE   $80             ; DSTATS
  2857 11FB E5			        .BYTE   <AUTORUN_APPKEY ; DBUFL
  2858 11FC 11			        .BYTE   >AUTORUN_APPKEY ; DBUFH
  2859 11FD 0F			        .BYTE   $0F             ; DTIMLO
  2860 11FE 00			        .BYTE   $00             ; DRESVD
  2861 11FF 06			        .BYTE   $06             ; DBYTL
  2862 1200 00			        .BYTE   $00             ; DBYTH
  2863 1201 00			        .BYTE   $00             ; DAUX1
  2864 1202 00			        .BYTE   $00             ; DAUX2
  2865
  2866 1203			APPKEYREADDCB:
  2867 1203 70			        .BYTE   $70             ; DDEVIC
  2868 1204 01			        .BYTE   $01             ; DUNIT
  2869 1205 DD			        .BYTE   $DD             ; DCOMND
  2870 1206 40			        .BYTE   $40             ; DSTATS
  2871 1207 80			        .BYTE   <LNBUF          ; DBUFL
  2872 1208 18			        .BYTE   >LNBUF          ; DBUFH
  2873 1209 01			        .BYTE   $01             ; DTIMLO - minimize timeout
  2874 120A 00			        .BYTE   $00             ; DRESVD
  2875 120B 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  2876 120C 00			        .BYTE   $00             ; DBYTH
  2877 120D 00			        .BYTE   $00             ; DAUX1
  2878 120E 00			        .BYTE   $00             ; DAUX2
  2879
  2880 120F			APPKEYWRITEDCB:
  2881 120F 70			        .BYTE   $70             ; DDEVIC
  2882 1210 01			        .BYTE   $01             ; DUNIT
  2883 1211 DE			        .BYTE   $DE             ; DCOMND
  2884 1212 80			        .BYTE   $80             ; DSTATS
  2885 1213 FF			        .BYTE   $FF             ; DBUFL
  2886 1214 05			        .BYTE   $05             ; DBUFH (expect page 5)
  2887 1215 0F			        .BYTE   $0F             ; DTIMLO
  2888 1216 00			        .BYTE   $00             ; DRESVD
  2889 1217 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  2890 1218 00			        .BYTE   $00             ; DBYTH
  2891 1219 FF			        .BYTE   $FF             ; DAUX1 (# actual bytes)
  2892 121A 00			        .BYTE   $00             ; DAUX2
  2893
  2894 				;---------------------------------------
  2895 121B			SUBMIT_AUTORUN:
  2896 				;---------------------------------------
  2897 				    ; At initial DOS boot, read URL for 
  2898 				    ; app key file from SD card's
  2899 				    ; FujiNet folder.
  2900 				    ;
  2901 				    ; filename: db790000.key
  2902 				    ; contents: url to a batch file
  2903 				    ;---------------------------------------
  2904 121B 20 72 0A		        JSR     LDBUFA
  2905
  2906 				    ; Open app key
  2907 121E A9 00		        LDA     #$00            ; Open for read
  2908 1220 8D E9 11		        STA     AUTORUN_APPKEY+4
  2909 1223 A9 F7		        LDA     #<APPKEYOPENDCB
  2910 1225 A0 11		        LDY     #>APPKEYOPENDCB
  2911 1227 20 A5 07		        JSR     DOSIOV
  2912
  2913 122A C0 01		        CPY     #$01            ; Was open successful?
  2914 122C F0 01		        BEQ     AUTOSUB_NEXT    ; Yes. Continue.
  2915 122E 60			        RTS                     ; No. Exit
  2916
  2917 122F			AUTOSUB_NEXT:
  2918 				    ; Read app key
  2919 122F A9 03		        LDA     #<APPKEYREADDCB
  2920 1231 A0 12		        LDY     #>APPKEYREADDCB
  2921 1233 20 A5 07		        JSR     DOSIOV
  2922
  2923 				    ; Close app key
  2924 1236 A9 EB		        LDA     #<APPKEYCLOSEDCB
  2925 1238 A0 11		        LDY     #>APPKEYCLOSEDCB
  2926 123A 20 A5 07		        JSR     DOSIOV
  2927
  2928 				    ; Does the returned URL contain something?
  2929 123D AE 80 18		        LDX     LNBUF           ; X contains strlen of AUTORUN path
  2930 1240 D0 01		        BNE     AUTORUN_CALL_SUBMIT
  2931
  2932
  2933 1242			AUTOSUB_DONE:
  2934 1242 60			        RTS
  2935
  2936 1243			AUTORUN_CALL_SUBMIT:
  2937 				    ; Replace end-of-line in buffer with null terminator
  2938 1243 CA			        DEX                     ; Move index back 1 position
  2939 1244 A9 00		        LDA     #$00            ;
  2940 1246 9D 82 18		        STA     LNBUF+2,X       ; Write null-terminator 
  2941 1249 A9 02		        LDA     #$02            ; Change arg1 location...
  2942 124B 8D 9A 0B		        STA     CMDSEP          ;  to point to filename
  2943
  2944 				    ;---------------------------------------
  2945 				    ; If here because of "AUTORUN ?", then
  2946 				    ; print contents of appkey file. But first
  2947 				    ; we have to terminate appkey string with EOL
  2948 				    ;---------------------------------------
  2949 124E AD 91 18		        LDA     AUTORUN_QUERY_FLG
  2950 1251 C9 3F		        CMP     #'?'
  2951 1253 D0 18		        BNE     SUBMIT_NEXT1
  2952
  2953 1255 A9 9B		        LDA     #EOL            ; Inject EOL to terminate string
  2954 1257 9D 82 18		        STA     LNBUF+2,X
  2955 125A A9 82		        LDA     #<(LNBUF+2)
  2956 125C A0 18		        LDY     #>(LNBUF+2)
  2957 125E 4C 89 0A		        JMP     PRINT_STRING    ; Print AUTORUN path and sneak out
  2958
  2959 				;---------------------------------------
  2960 1261			DO_SUBMIT:
  2961 				;---------------------------------------
  2962 1261 AD 9A 0B		        LDA     CMDSEP
  2963 1264 D0 07		        BNE     SUBMIT_NEXT1
  2964
  2965 				    ; Filename required
  2966 1266 A9 6F		        LDA     #<MISSING_FILE_STR
  2967 1268 A0 17		        LDY     #>MISSING_FILE_STR
  2968 126A 4C 89 0A		        JMP     PRINT_STRING
  2969
  2970 126D			SUBMIT_NEXT1:
  2971
  2972 				    ; Default to NOSCREEN
  2973 126D A9 00		        LDA     #$00
  2974 126F 8D 78 17		        STA     ECHO_FLG
  2975
  2976 				    ; Prep file path
  2977 1272 20 7D 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2978 1275 20 C4 15		        JSR     PREPEND_DRIVE
  2979
  2980 				    ; Assert FILE #1 is closed
  2981 1278 A2 10		        LDX     #$10
  2982 127A 20 BB 09		        JSR     CIOCLOSE
  2983 				        
  2984 				    ; OPEN #1, 4, 0, file path
  2985 127D A2 10		        LDX     #$10            ; File #1
  2986 127F A0 04		        LDY     #$04            ; Open for input
  2987 1281 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2988 1284 10 03		        BPL     SUBMIT_NEXT2
  2989 1286 4C A4 0A		        JMP     PRINT_ERROR
  2990
  2991 				    ; Read batch file character by character
  2992 				    ; This allows it be end-of-line agnostic
  2993 				    ; Branch forward when an end-of-line is interpretted.
  2994
  2995 1289			SUBMIT_NEXT2:
  2996 1289 20 72 0A		        JSR     LDBUFA      ; Reset INBUFF to $0580
  2997 128C C6 F3		        DEC     INBUFF      ; Init 1 byte before buffer
  2998 128E A9 FF		        LDA     #$FF        ; Clear command
  2999 1290 8D 76 17		        STA     CMD
  3000
  3001 1293			SUBMIT_GETCH:
  3002 1293 E6 F3		        INC     INBUFF          ; Advance pointer
  3003 1295 D0 02		        BNE     SUBMIT_NEXT3
  3004 1297 E6 F4		        INC     INBUFF+1
  3005
  3006 1299			SUBMIT_NEXT3:
  3007 1299 A2 10		        LDX     #$10            ; OPEN #1
  3008 129B A9 01		        LDA     #$01            ; Get 1 byte
  3009 129D A0 00		        LDY     #$00            ; ditto
  3010
  3011 129F 20 F0 09		        JSR     CIOGET          ; Get byte from file
  3012 12A2 A0 00		        LDY     #$00            ;
  3013 12A4 B1 F3		        LDA     (INBUFF),Y      ; byte will be here
  3014 				        
  3015 12A6 C9 0D		        CMP     #CR             ; Just skip if Windows CR
  3016 12A8 F0 E9		        BEQ     SUBMIT_GETCH
  3017
  3018 12AA C9 0A		        CMP     #LF             ; Convert LF to EOL
  3019 12AC D0 04		        BNE     SUBMIT_EOL
  3020 12AE A9 9B		        LDA     #EOL
  3021 12B0 91 F3		        STA     (INBUFF),Y
  3022
  3023 12B2			SUBMIT_EOL:
  3024 12B2 C9 9B		        CMP     #EOL            ; At end of command line?
  3025 12B4 D0 DD		        BNE     SUBMIT_GETCH    ; No. Get next byte.
  3026
  3027 				    ; Here if we've reached the end of a command line.
  3028 				    ; At end of file?
  3029 12B6 A2 10		        LDX     #$10            ; Channel #1
  3030 12B8 BD 43 03		        LDA     ICSTA,X         ; Inspect return code
  3031 12BB C9 88		        CMP     #EOF
  3032 12BD F0 22		        BEQ     SUBMIT_DONE     ; No error, try parsing cmd
  3033
  3034 12BF AD 78 17		        LDA     ECHO_FLG        ; Skip echo if SCREEN is disabled
  3035 12C2 F0 11		        BEQ     SUBMIT_NEXT4
  3036 12C4 AD 80 18		        LDA     LNBUF
  3037 12C7 C9 40		        CMP     #'@'            ; Skip lines beginning with @
  3038 12C9 F0 0A		        BEQ     SUBMIT_NEXT4
  3039
  3040 				    ; Echo commands
  3041 12CB 20 72 0A		        JSR     LDBUFA
  3042 12CE A5 F3		        LDA     INBUFF
  3043 12D0 A4 F4		        LDY     INBUFF+1
  3044 12D2 20 89 0A		        JSR     PRINT_STRING
  3045
  3046 12D5			SUBMIT_NEXT4:
  3047 12D5 20 48 0B		        JSR     GETCMDTEST
  3048 12D8 20 9E 0B		        JSR     PARSECMD
  3049 12DB 20 51 0C		        JSR     DOCMD
  3050 12DE 38			        SEC
  3051 12DF B0 A8		        BCS     SUBMIT_NEXT2
  3052
  3053 12E1			SUBMIT_DONE
  3054 12E1 A2 10		        LDX     #$10
  3055 12E3 4C BB 09		        JMP     CIOCLOSE
  3056
  3057 				; End of DO_SUBMIT
  3058 				;---------------------------------------
  3059
  3060 				;---------------------------------------
  3061 12E6			DO_TYPE:
  3062 				;---------------------------------------
  3063 12E6 AD 9A 0B		        LDA     CMDSEP
  3064 12E9 D0 07		        BNE     TYPE_SKIP
  3065
  3066 12EB			TYPE_USAGE:
  3067 12EB A9 6F		        LDA     #<MISSING_FILE_STR
  3068 12ED A0 17		        LDY     #>MISSING_FILE_STR
  3069 12EF 4C 89 0A		        JMP     PRINT_STRING
  3070
  3071 12F2			TYPE_SKIP:
  3072 12F2 20 7D 0C		        JSR     GET_DOSDR       ; Get DUNIT
  3073 12F5 20 C4 15		        JSR     PREPEND_DRIVE
  3074
  3075 				    ; Assert input file closed
  3076 12F8 A2 10		        LDX     #$10            ; File #1
  3077 12FA 20 BB 09		        JSR     CIOCLOSE        ; Assert file #1 is closed
  3078
  3079 				    ; Open input file
  3080 12FD A2 10		        LDX     #$10            ; File #1
  3081 12FF A0 04		        LDY     #$04            ; Open for input
  3082 1301 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  3083 1304 10 08		        BPL     TYPE_NEXT
  3084
  3085 				    ; If open failed, Print error
  3086 1306 A2 10		        LDX     #$10            ; File #1
  3087 1308 BC 43 03		        LDY     ICSTA,X
  3088 130B 4C A4 0A		        JMP     PRINT_ERROR
  3089
  3090 130E			TYPE_NEXT:
  3091
  3092 				    ; Initialize pagination
  3093 130E 20 AD 13		        JSR     DO_CLS
  3094 1311 A9 15		        LDA     #21
  3095 1313 8D BB 02		        STA     SCRFLG
  3096
  3097 1316			TYPE_LOOP:
  3098 				    ; Bail if ESC key is pressed
  3099 1316 AD FC 02		        LDA     CH
  3100 1319 C9 1C		        CMP     #ESC_KEY
  3101 131B F0 49		        BEQ     TYPE_DONE
  3102
  3103 				    ; Check if page is full
  3104 131D AD BB 02		        LDA     SCRFLG
  3105 1320 C9 16		        CMP     #22             ; if SCRFLG < 21
  3106 1322 90 14		        BCC     TYPE_READ       ; then skip to read
  3107
  3108 				    ; Here if page is full
  3109 				    ; Wait for keypress
  3110 1324 A9 FF		        LDA     #$FF            ; Clear keypress
  3111 1326 8D FC 02		        STA     CH
  3112
  3113 1329			TYPE_WAIT:
  3114 1329 AE FC 02		        LDX     CH              ; Will be $FF if no keypress
  3115 132C E8			        INX                     ; $FF --> $00
  3116 132D F0 FA		        BEQ     TYPE_WAIT       ; Keep waiting if $00
  3117
  3118 132F E0 1C		        CPX     #ESC_KEY        ; Leave if ESC key pressed
  3119 1331 F0 33		        BEQ     TYPE_DONE
  3120
  3121 				    ; Reset pagination
  3122 1333 A9 00		        LDA     #$00
  3123 1335 8D BB 02		        STA     SCRFLG
  3124
  3125 1338			TYPE_READ:
  3126 				    ; Read from file
  3127 1338 A2 10		        LDX     #$10
  3128 133A A9 01		        LDA     #$01
  3129 133C A0 00		        LDY     #$00
  3130 133E 20 F0 09		        JSR     CIOGET
  3131
  3132 				    ; Quit if EOF
  3133 1341 A2 10		        LDX     #$10
  3134 1343 BD 43 03		        LDA     ICSTA,X
  3135 1346 C9 88		        CMP     #EOF
  3136 1348 F0 1C		        BEQ     TYPE_DONE
  3137
  3138 				    ; Convert CRLF or LF --> EOL
  3139 134A A0 00		        LDY     #$00
  3140 134C B1 F3		        LDA     (INBUFF),Y
  3141 134E C9 0D		        CMP     #CR     ; Skip CR
  3142 1350 F0 11		        BEQ     TYPE_NEXT3
  3143 1352 C9 0A		        CMP     #LF     ; Convert LF --> EOL
  3144 1354 D0 04		        BNE     TYPE_NEXT2
  3145 1356 A9 9B		        LDA     #EOL
  3146 1358 91 F3		        STA     (INBUFF),Y
  3147
  3148 135A			TYPE_NEXT2:
  3149 				    ; Write to screen
  3150 135A A2 00		        LDX     #$00
  3151 135C A9 01		        LDA     #$01
  3152 135E A0 00		        LDY     #$00
  3153 1360 20 0E 0A		        JSR     CIOPUT
  3154
  3155 1363			TYPE_NEXT3:
  3156 				    ; Do next
  3157 1363 4C 16 13		        JMP     TYPE_LOOP
  3158 				        
  3159 1366			TYPE_DONE:
  3160 1366 A9 FF		        LDA     #$FF
  3161 1368 8D FC 02		        STA     CH
  3162 136B A2 10		        LDX     #$10            ; Close File #1
  3163 136D 4C BB 09		        JMP     CIOCLOSE        ; 
  3164
  3165 1370			TYPE_OPEN_ERR_STR:
  3166 1370 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO OPEN FILE',EOL
  3167
  3168 				;;---------------------------------------
  3169 				;DO_UNLOCK:
  3170 				;;---------------------------------------
  3171 				;        LDA     #$90
  3172 				;        STA     COLOR2
  3173 				;        RTS
  3174
  3175 				;---------------------------------------
  3176 1384			DO_CAR:
  3177 				;---------------------------------------
  3178
  3179 				    ;---------------------------------------
  3180 				    ; Is cart address space RAM or ROM?
  3181 				    ;---------------------------------------
  3182 1384 AD 00 A0		        LDA     $A000
  3183 1387 EE 00 A0		        INC     $A000
  3184 138A CD 00 A0		        CMP     $A000
  3185 138D F0 0A		        BEQ     DO_CAR_NEXT
  3186
  3187 				    ;---------------------------------------
  3188 				    ; RAM found
  3189 				    ;---------------------------------------
  3190 138F 8D 00 A0		        STA     $A000
  3191 1392 A9 A0		        LDA     #<DO_CAR_ERR
  3192 1394 A0 13		        LDY     #>DO_CAR_ERR
  3193 1396 4C 89 0A		        JMP     PRINT_STRING
  3194
  3195 1399			DO_CAR_NEXT:
  3196 1399 A9 FF		        LDA     #$FF
  3197 139B 85 08		        STA     $08         ; Warmstart
  3198 139D 6C FA BF		        JMP     ($BFFA)
  3199
  3200 13A0			DO_CAR_ERR:
  3201 13A0 4E 4F 20 43 41 52 +         .BYTE   'NO CARTRIDGE',EOL
  3202
  3203 				;---------------------------------------
  3204 13AD			DO_CLS:
  3205 				;---------------------------------------
  3206 13AD A9 B4		        LDA     #<CLS_STR
  3207 13AF A0 13		        LDY     #>CLS_STR
  3208 13B1 4C 89 0A		        JMP     PRINT_STRING
  3209
  3210 13B4			CLS_STR:
  3211 13B4 7D 9B		        .BYTE   125,EOL
  3212
  3213 				;---------------------------------------
  3214 13B6			DO_COLD:
  3215 				;---------------------------------------
  3216 13B6 4C 77 E4		        JMP     COLDSV
  3217
  3218 				;---------------------------------------
  3219 13B9			DO_HELP:
  3220 				;---------------------------------------
  3221 				    ; Append either "HELP" or arg1 to URL
  3222 13B9 A2 00		        LDX     #$00        ; index to start of article buf
  3223 13BB AC 9A 0B		        LDY     CMDSEP      ; index to cmd line arg
  3224 				        
  3225 13BE			HELP_LOOP1:
  3226 13BE B1 F3		        LDA     (INBUFF),Y
  3227 13C0 C9 9B		        CMP     #EOL
  3228 13C2 F0 14		        BEQ     HELP_NEXT1  ; Exit loop at end of arg
  3229 13C4 E0 16		        CPX     #22
  3230 13C6 10 2E		        BPL     HELP_DONE   ; Exit if arg is too long
  3231
  3232 				    ; Convert lower-case to upper-case
  3233 13C8 20 60 0A		        JSR     TOUPPER
  3234 				;        CMP     #'a'        ; SKip if < 'a'
  3235 				;        BCC     @+
  3236 				;        CMP     #'z'+1      ; Skip if > 'z'
  3237 				;        BCS     @+
  3238 				;        AND     #$5F        ; Convert to lower to upper
  3239
  3240 13CB 9D 52 14		        STA     HELP_ARTICLE,X
  3241 13CE E8			        INX
  3242 13CF C8			        INY
  3243 13D0 D0 EC		        BNE     HELP_LOOP1  ; Always true
  3244
  3245 				    ; Append .DOC extension to article name
  3246 13D2			HELP_EXT:
  3247 13D2 2E 44 4F 43 9B 00	        .BYTE   '.DOC',EOL,$00
  3248
  3249 13D8			HELP_NEXT1:
  3250 13D8 A0 00		        LDY     #$00
  3251
  3252 13DA			HELP_LOOP2:
  3253 13DA B9 D2 13		        LDA     HELP_EXT,Y
  3254 13DD 9D 52 14		        STA     HELP_ARTICLE,X  ; Store null term too
  3255 13E0 F0 04		        BEQ     HELP_NEXT2      ; Skip ahead if terminator
  3256 13E2 E8			        INX
  3257 13E3 C8			        INY
  3258 13E4 D0 F4		        BNE     HELP_LOOP2  ; Always true
  3259
  3260 13E6			HELP_NEXT2:
  3261 				    ; Copy URL to LNBUF
  3262 13E6 A2 00		        LDX     #$00    ; Index to start of HELP_URL
  3263 13E8 A0 05		        LDY     #$05    ; Index to start at arg1 for "TYPE "
  3264 				    
  3265 13EA			HELP_LOOP3:
  3266 13EA BD FE 13		        LDA     HELP_URL,X  ; Get source byte
  3267 13ED 99 80 18		        STA     LNBUF,Y     ; Write to target location
  3268 13F0 F0 04		        BEQ     HELP_DONE   ; Exit loop on null terminator
  3269 13F2 E8			        INX                 ; Advance indices
  3270 13F3 C8			        INY
  3271 13F4 D0 F4		        BNE     HELP_LOOP3  ; Always true
  3272 				        
  3273 13F6			HELP_DONE:        
  3274 13F6 A9 05		        LDA     #$05        ; Trick TYPE to look for URL in arg1
  3275 13F8 8D 9A 0B		        STA     CMDSEP
  3276 13FB 4C E6 12		        JMP     DO_TYPE
  3277
  3278 13FE			HELP_URL:
  3279 13FE 4E 38 3A 48 54 54 +         .BYTE   'N8:HTTPS://raw.githubusercontent.com/michaelsternberg/fujinet-nhandler/nos/nos/HELP/'
  3280
  3281 1452			HELP_ARTICLE:
  3282 1452 00 00 00 00 00 00 +     :24 .BYTE   $00
  3283
  3284 				;---------------------------------------
  3285 146A			DO_NOBASIC:
  3286 				;---------------------------------------
  3287 				    ; Quit if 400/800
  3288 146A AD F7 FF		        LDA     $FFF7
  3289 146D C9 FF		        CMP     #$FF        ; ????
  3290 146F F0 21		        BEQ     NOBASIC_ERROR
  3291 1471 C9 DD		        CMP     #$DD        ; OSA NTSC
  3292 1473 F0 1D		        BEQ     NOBASIC_ERROR
  3293 1475 C9 F3		        CMP     #$F3        ; OSB NTSC
  3294 1477 F0 19		        BEQ     NOBASIC_ERROR
  3295 1479 C9 D6		        CMP     #$D6        ; OSA PAL
  3296 147B F0 15		        BEQ     NOBASIC_ERROR
  3297 147D C9 22		        CMP     #$22        ; OSB PAL
  3298 147F F0 11		        BEQ     NOBASIC_ERROR
  3299 1481 C9 0A		        CMP     #$0A        ; OSA 1200XL
  3300 1483 F0 0D		        BEQ     NOBASIC_ERROR
  3301 1485 C9 0B		        CMP     #$0B        ; OSB 1200XL
  3302 1487 F0 09		        BEQ     NOBASIC_ERROR
  3303 				        
  3304 				    ; Disable BASIC
  3305 1489 AD 01 D3		        LDA     PORTB
  3306 148C 09 02		        ORA     #%00000010  ; if Bit 1 = 1 then BASIC is disabled
  3307 148E 8D 01 D3		        STA     PORTB
  3308 1491 60			        RTS
  3309
  3310 				;---------------------------------------
  3311 1492			NOBASIC_ERROR:
  3312 				;---------------------------------------
  3313 1492 A9 99		        LDA     #<NOBASIC_ERROR_STR
  3314 1494 A0 14		        LDY     #>NOBASIC_ERROR_STR
  3315 1496 4C 89 0A		        JMP     PRINT_STRING
  3316
  3317 1499			NOBASIC_ERROR_STR:
  3318 1499 4E 4F 20 42 55 49 +         .BYTE   'NO BUILT-IN BASIC',EOL
  3319
  3320 				;---------------------------------------
  3321 14AB			DO_NOSCREEN:
  3322 				;---------------------------------------
  3323 14AB A9 00		        LDA     #$00
  3324 14AD 8D 78 17		        STA     ECHO_FLG    ; Disable echo in batch processing
  3325 14B0 60			        RTS
  3326
  3327 				;---------------------------------------
  3328 14B1			DO_SCREEN:
  3329 				;---------------------------------------
  3330 14B1 A9 01		        LDA     #$01
  3331 14B3 8D 78 17		        STA     ECHO_FLG    ; Enable echo in batch processing
  3332 14B6 60			        RTS
  3333
  3334 				;---------------------------------------
  3335 14B7			DO_PRINT:
  3336 				;---------------------------------------
  3337 14B7 AD 9A 0B		        LDA     CMDSEP
  3338 14BA F0 08		        BEQ     PRINT_DONE
  3339
  3340 14BC 18			        CLC
  3341 14BD 65 F3		        ADC     INBUFF
  3342 14BF A4 F4		        LDY     INBUFF+1
  3343 14C1 4C 89 0A		        JMP     PRINT_STRING
  3344
  3345 14C4			PRINT_DONE:
  3346 14C4 60			        RTS
  3347
  3348 				;---------------------------------------
  3349 14C5			DO_REENTER:
  3350 				;---------------------------------------
  3351 				    ; Jump to the address stored in RUNAD or INITAD
  3352 				    ; Do the one that isn't pointing to R (RUNAD first)
  3353
  3354 				    ; Skip it all if both contain $0000
  3355 14C5 AD E2 02		        LDA     INITAD
  3356 14C8 D0 16		        BNE     DO_REENTER_CONT
  3357 14CA AD E3 02		        LDA     INITAD+1
  3358 14CD D0 11		        BNE     DO_REENTER_CONT
  3359 14CF AD E0 02		        LDA     RUNAD
  3360 14D2 D0 0C		        BNE     DO_REENTER_CONT
  3361 14D4 AD E1 02		        LDA     RUNAD+1
  3362 14D7 D0 07		        BNE     DO_REENTER_CONT
  3363
  3364 14D9 A9 F4		        LDA     #<DO_REENTER_ERR
  3365 14DB A0 14		        LDY     #>DO_REENTER_ERR
  3366 14DD 4C 89 0A		        JMP     PRINT_STRING
  3367
  3368 14E0			DO_REENTER_CONT:
  3369 14E0 AD E0 02		        LDA     RUNAD
  3370 14E3 C9 0E		        CMP     #>R
  3371 14E5 D0 07		        BNE     DO_REENTER_RUNAD
  3372 14E7 AD E1 02		        LDA     RUNAD+1
  3373 14EA C9 0E		        CMP     #>R
  3374 14EC F0 03		        BEQ     DO_REENTER_INITAD
  3375
  3376 14EE			DO_REENTER_RUNAD:
  3377 14EE 6C E0 02		        JMP     (RUNAD)     ; Godspeed
  3378
  3379 14F1			DO_REENTER_INITAD:
  3380 14F1 6C E2 02		        JMP     (INITAD)    ; Godspeed
  3381
  3382 14F4			DO_REENTER_ERR:
  3383 14F4 4E 4F 20 41 44 44 +         .BYTE   'NO ADDR IN INITAD OR RUNAD',EOL
  3384
  3385 				;---------------------------------------
  3386 150F			DO_REM:
  3387 				;---------------------------------------
  3388 150F 60			        RTS
  3389
  3390 				;---------------------------------------
  3391 1510			DO_RUN:
  3392 				;---------------------------------------
  3393 1510 AD 9A 0B		        LDA     CMDSEP      ; Get position for address arg
  3394 1513 A8			        TAY                 ; Offset to arg used later
  3395 1514 18			        CLC
  3396 1515 69 04		        ADC     #$04
  3397 1517 8D 00 18		        STA     RBUF
  3398
  3399 				    ;---------------------------------------
  3400 				    ; ASCII hex char to integer conversion
  3401 				    ; algorithm borrowed from Apple II Monitor
  3402 				    ;---------------------------------------
  3403 151A A9 00		        LDA     #$00
  3404 151C 85 F3		        STA     INBUFF      ; L
  3405 151E 85 F4		        STA     INBUFF+1    ; H
  3406 1520			NEXTHEX:
  3407 1520 B9 80 18		        LDA     LNBUF,Y     ; Get character for hex test.
  3408 1523 49 30		        EOR     #%00110000  ; Maps digits to $0-$9
  3409 1525 C9 0A		        CMP     #$0A        ; Digit?
  3410 1527 90 06		        BCC     DIG         ; Yes.
  3411 1529 69 88		        ADC     #$88        ; Map letter "A"-"F" to $FA-FF.
  3412 152B C9 FA		        CMP     #$FA        ; Hex letter?
  3413 152D 90 17		        BCC     NOTHEX      ; No, character not hex.
  3414
  3415 152F 0A			DIG:    ASL
  3416 1530 0A			        ASL
  3417 1531 0A			        ASL
  3418 1532 0A			        ASL
  3419 1533 A2 04		        LDX     #$04        ; Shift count.
  3420
  3421 1535			HEXSHIFT:
  3422 1535 0A			        ASL
  3423 1536 26 F3		        ROL     INBUFF      ; Rotate into LSD.
  3424 1538 26 F4		        ROL     INBUFF+1    ; Rotate into MSD's.
  3425 153A CA			        DEX                 ; Done 4 shifts?
  3426 153B D0 F8		        BNE     HEXSHIFT    ; No, loop.
  3427 153D C8			        INY                 ; Advance text index
  3428 153E CC 00 18		        CPY     RBUF        ; Processed 4 characters?
  3429 1541 D0 DD		        BNE     NEXTHEX     ; No, get next character.
  3430
  3431 1543 6C F3 00		        JMP     (INBUFF)    ; Goto requested address. Godspeed.
  3432
  3433 1546			NOTHEX:
  3434 1546 A9 4D		        LDA     #<RUN_ERROR_STR
  3435 1548 A0 15		        LDY     #>RUN_ERROR_STR
  3436 154A 4C 89 0A		        JMP     PRINT_STRING
  3437
  3438 154D			RUN_ERROR_STR:
  3439 154D 41 44 44 52 3F 20 +         .BYTE   'ADDR? 0000..FFFF',EOL
  3440
  3441 				;---------------------------------------
  3442 155E			DO_WARM:
  3443 				;---------------------------------------
  3444 155E 4C 74 E4		        JMP     WARMSV
  3445
  3446 				;---------------------------------------
  3447 1561			DO_XEP:
  3448 				;---------------------------------------
  3449 1561 A0 19		        LDY     #$19        ; CMD = $19 (enter 40 col)
  3450 1563 AE 9A 0B		        LDX     CMDSEP
  3451 1566 BD 80 18		        LDA     LNBUF,X
  3452 1569 C9 34		        CMP     #'4'
  3453 156B F0 01		        BEQ     @+
  3454 156D 88			        DEY                 ; CMD = $18 (enter 80 col)
  3455 156E			@:      
  3456 156E A2 00		        LDX     #$00
  3457 1570 98			        TYA
  3458 1571 9D 42 03		        STA     ICCOM,X
  3459 1574 A9 8E		        LDA     #<EDEV
  3460 1576 9D 44 03		        STA     ICBAL,X
  3461 1579 A9 15		        LDA     #>EDEV
  3462 157B 9D 45 03		        STA     ICBAH,X
  3463 157E A9 2C		        LDA     #$2C
  3464 1580 9D 4A 03		        STA     ICAX1,X
  3465 1583 A9 00		        LDA     #$00
  3466 1585 9D 4B 03		        STA     ICAX2,X
  3467 1588 20 56 E4		        JSR     CIOV
  3468 158B 4C AD 13		        JMP     DO_CLS
  3469
  3470 158E 25 1A 9B		EDEV:   .BYTE   "E:",EOL
  3471 				        
  3472 				;---------------------------------------
  3473 1591			REMOUNT_DRIVE:
  3474 				;---------------------------------------
  3475
  3476 				    ;---------------------------------------
  3477 				    ; Workaround for timeout issue regarding idempotent commands that
  3478 				    ; unmount the server.  So far, these are DEL and RENAME. This
  3479 				    ; routine, remounts the TNFS URL by calling NPWD and attempts
  3480 				    ; a MKDIR on the returned mount point. Hopefully this is an
  3481 				    ; non-consequential operation since the directory already exists.
  3482 				    ;---------------------------------------
  3483
  3484 1591 20 CC 10		        JSR     DO_NPWD         ; Curr dir for drive now in RBUF
  3485
  3486 1594 AD 00 18		        LDA     RBUF            ; Quit if not TNFS. Only TNFS is affected.
  3487 1597 C9 54		        CMP     #'T'            ; TODO More letters needed if...
  3488 1599 D0 28		        BNE     REMOUNT_DONE    ; ...another Txxx protocol exists
  3489
  3490 159B A9 4E		        LDA     #'N'
  3491 159D 8D 00 18		        STA     RBUF+0
  3492 15A0 AD 75 17		        LDA     DOSDR           ; Get drive number
  3493 15A3 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  3494 15A5 8D 01 18		        STA     RBUF+1
  3495 15A8 A9 3A		        LDA     #':'
  3496 15AA 8D 02 18		        STA     RBUF+2
  3497
  3498 15AD A9 2A		        LDA     #CMD_MKDIR
  3499 15AF 8D 03 0D		        STA     GENDCB+2
  3500 15B2 A9 00		        LDA     #<RBUF          ; TODO Is this needed
  3501 15B4 8D 05 0D		        STA     GENDCB+4        ; TODO or is it hardcoded in DO_GENERIC?
  3502 15B7 A9 18		        LDA     #>RBUF
  3503 15B9 8D 06 0D		        STA     GENDCB+5
  3504
  3505 15BC A9 01		        LDA     #<GENDCB
  3506 15BE A0 0D		        LDY     #>GENDCB
  3507 15C0 4C A5 07		        JMP     DOSIOV
  3508
  3509 15C3			REMOUNT_DONE:
  3510 15C3 60			        RTS
  3511
  3512 				;---------------------------------------
  3513 15C4			PREPEND_DRIVE:
  3514 				;---------------------------------------
  3515 				        ; Inject "Nn:" in front of a plain filename
  3516 				        ; before passing it to the FujiNet
  3517 15C4 A0 00		        LDY     #$00
  3518 15C6 A9 4E		        LDA     #'N'
  3519 15C8 D1 F3		        CMP     (INBUFF),Y  ; Does arg1 already begin with N?
  3520
  3521 15CA A0 02		        LDY     #$02
  3522 15CC A9 3A		        LDA     #':'
  3523 15CE D1 F3		        CMP     (INBUFF),Y
  3524 15D0 F0 1C		        BEQ     PREPEND_DRIVE_DONE
  3525 15D2 88			        DEY
  3526 15D3 D1 F3		        CMP     (INBUFF),Y
  3527 15D5 F0 17		        BEQ     PREPEND_DRIVE_DONE
  3528
  3529 				        ; Move input buffer pointer back 3 bytes
  3530 15D7 38			        SEC
  3531 15D8 A5 F3		        LDA     INBUFF
  3532 15DA E9 03		        SBC     #$03
  3533 15DC 85 F3		        STA     INBUFF
  3534 15DE A5 F4		        LDA     INBUFF+1
  3535 15E0 E9 00		        SBC     #$00
  3536 15E2 85 F4		        STA     INBUFF+1
  3537
  3538 				        ; Inject PRMPT to front of arg1
  3539 15E4 A0 03		        LDY     #$03
  3540 15E6			PREPEND_DRIVE_LOOP:
  3541 15E6 B9 18 16		        LDA     PRMPT,Y
  3542 15E9 88			        DEY
  3543 15EA 91 F3		        STA     (INBUFF),Y
  3544 15EC D0 F8		        BNE     PREPEND_DRIVE_LOOP
  3545
  3546 15EE			PREPEND_DRIVE_DONE:
  3547 15EE A0 01		        LDY     #$01
  3548 15F0 60			        RTS             ; Y = $00 here
  3549
  3550 				;---------------------------------------
  3551 15F1			APPEND_SLASH:
  3552 				;---------------------------------------
  3553 				    ;---------------------------------------
  3554 				    ; Skip if relative path (..)
  3555 				    ;---------------------------------------
  3556 15F1 A0 00		        LDY     #$00
  3557 15F3 A9 2E		        LDA     #'.'
  3558 15F5 D1 F3		        CMP     (INBUFF),Y
  3559 15F7 F0 1E		        BEQ     APPEND_SLASH_DONE
  3560
  3561 15F9 A0 FF		        LDY     #$FF        ; Iterate thru arg2 until EOF
  3562 15FB			APPEND_SLASH_LOOP:
  3563 15FB C8			        INY                 ; Zero on 1st pass
  3564 15FC B1 F3		        LDA     (INBUFF),Y
  3565 15FE C9 9B		        CMP     #EOL
  3566 1600 D0 F9		        BNE     APPEND_SLASH_LOOP
  3567
  3568 1602 88			        DEY                 ; Move pointer back one character
  3569 1603 B1 F3		        LDA     (INBUFF),Y
  3570 1605 C9 2F		        CMP     #'/'        ; If already slash then skip rest
  3571 1607 F0 0E		        BEQ     APPEND_SLASH_DONE
  3572 1609 C9 3A		        CMP     #':'        ; If a drive, skip
  3573 160B F0 0A		        BEQ     APPEND_SLASH_DONE
  3574
  3575 160D C8			        INY                 ; Else inject '/' + EOL
  3576 160E A9 2F		        LDA     #'/'
  3577 1610 91 F3		        STA     (INBUFF),Y
  3578 1612 C8			        INY
  3579 1613 A9 9B		        LDA     #EOL
  3580 1615 91 F3		        STA     (INBUFF),Y
  3581
  3582 1617			APPEND_SLASH_DONE:
  3583 1617 60			        RTS
  3584
  3585 1618			PRMPT:
  3586 1618 9B 4E 20 3A		        .BYTE   EOL,'N :'
  3587
  3588 				;;; End CP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  3589 				;;; Variables
  3590
  3591 161C			        .ENUM   CMD_IDX
  3592 				        ;---------------
  3593 = 0000			                NCD                 ;  0
  3594 				;                COPY                ;  1
  3595 = 0001			                DIR                 ;  2
  3596 = 0002			                DEL                 ;  3
  3597 = 0003			                LOAD                ;  4
  3598 				;                LOCK                ;  5
  3599 = 0004			                LOGIN               ;  6
  3600 = 0005			                LPR                 ;  7
  3601 = 0006			                MKDIR               ;  8
  3602 = 0007			                NPWD                ;  9
  3603 = 0008			                NTRANS              ; 10
  3604 = 0009			                RENAME              ; 11
  3605 = 000A			                RMDIR               ; 12
  3606 = 000B			                SUBMIT              ; 13
  3607 = 000C			                TYPE                ; 14
  3608 				;                UNLOCK              ; 15
  3609 = 000D			                AUTORUN             ; 16
  3610 = 000E			                CAR                 ; 17
  3611 = 000F			                CLS                 ; 18
  3612 = 0010			                COLD                ; 19
  3613 = 0011			                HELP                ; 20
  3614 = 0012			                NOBASIC             ; 21
  3615 = 0013			                NOSCREEN            ; 22
  3616 = 0014			                PRINT               ; 23
  3617 = 0015			                REENTER             ; 24
  3618 = 0016			                REM                 ; 25
  3619 = 0017			                RUN                 ; 26
  3620 = 0018			                SCREEN              ; 27
  3621 = 0019			                WARM                ; 28
  3622 = 001A			                XEP                 ; 29
  3623 = 001B			                DRIVE_CHG           ; 30
  3624 				        .ENDE
  3625
  3626 161C			CMD_DCOMND:
  3627 161C 2C			        .BYTE   CMD_CD              ;  0 NCD
  3628 				;        .BYTE   CMD_COPY            ;  1 COPY
  3629 161D 02			        .BYTE   CMD_DIR             ;  2 DIR
  3630 161E 21			        .BYTE   CMD_DEL             ;  3 DEL
  3631 161F 28			        .BYTE   CMD_LOAD            ;  4 LOAD
  3632 				;        .BYTE   CMD_LOCK            ;  5 LOCK
  3633 1620 FD			        .BYTE   CMD_LOGIN           ;  6 LOGIN
  3634 1621 F0			        .BYTE   CMD_LPR             ;  7 LPR
  3635 1622 2A			        .BYTE   CMD_MKDIR           ;  8 MKDIR
  3636 1623 30			        .BYTE   CMD_NPWD            ;  9 NPWD
  3637 1624 54			        .BYTE   CMD_NTRANS          ; 10 NTRANS
  3638 1625 20			        .BYTE   CMD_RENAME          ; 11 RENAME
  3639 1626 2B			        .BYTE   CMD_RMDIR           ; 12 RMDIR
  3640 1627 F0			        .BYTE   CMD_SUBMIT          ; 13 SUBMIT
  3641 1628 F0			        .BYTE   CMD_TYPE            ; 14 TYPE
  3642 				;        .BYTE   CMD_UNLOCK          ; 15 UNLOCK
  3643 1629 F0			        .BYTE   CMD_AUTORUN         ; 16 AUTORUN
  3644 162A F0			        .BYTE   CMD_CAR             ; 17 CAR
  3645 162B F0			        .BYTE   CMD_CLS             ; 18 CLS
  3646 162C F0			        .BYTE   CMD_COLD            ; 19 COLD
  3647 162D F0			        .BYTE   CMD_HELP            ; 20 HELP
  3648 162E F0			        .BYTE   CMD_NOBASIC         ; 21 NOBASIC
  3649 162F F0			        .BYTE   CMD_NOSCREEN        ; 22 NOSCREEN
  3650 1630 F0			        .BYTE   CMD_PRINT           ; 23 PRINT
  3651 1631 F0			        .BYTE   CMD_REENTER         ; 24 REENTER
  3652 1632 F0			        .BYTE   CMD_REM             ; 25 REM
  3653 1633 F0			        .BYTE   CMD_RUN             ; 26 RUN
  3654 1634 F0			        .BYTE   CMD_SCREEN          ; 27 SCREEN
  3655 1635 F0			        .BYTE   CMD_WARM            ; 28 WARM
  3656 1636 F0			        .BYTE   CMD_XEP             ; 29 XEP
  3657 1637 01			        .BYTE   CMD_DRIVE_CHG       ; 30
  3658
  3659 1638			COMMAND:
  3660 1638 4E 43 C4		        .CB     "NCD"               ;  0 NCD
  3661 163B 00			        .BYTE   CMD_IDX.NCD            
  3662
  3663 				;        .CB     "COPY"              ;  1 COPY
  3664 				;        .BYTE   CMD_IDX.COPY           
  3665
  3666 163C 44 49 D2		        .CB     "DIR"               ;  2 DIR
  3667 163F 01			        .BYTE   CMD_IDX.DIR              
  3668
  3669 1640 44 45 CC		        .CB     "DEL"               ;  3 DEL
  3670 1643 02			        .BYTE   CMD_IDX.DEL              
  3671
  3672 1644 4C 4F 41 C4		        .CB     "LOAD"              ;  4 LOAD
  3673 1648 03			        .BYTE   CMD_IDX.LOAD             
  3674
  3675 				;        .CB     "LOCK"              ;  5 LOCK
  3676 				;        .BYTE   CMD_IDX.LOCK             
  3677
  3678 1649 4C 4F 47 49 CE	        .CB     "LOGIN"             ;  6 LOGIN
  3679 164E 04			        .BYTE   CMD_IDX.LOGIN              
  3680 				                                        
  3681 164F 4C 50 D2		        .CB     "LPR"               ;  7 LPR
  3682 1652 05			        .BYTE   CMD_IDX.LPR                
  3683 				                                          
  3684 1653 4D 4B 44 49 D2	        .CB     "MKDIR"             ;  8 MKDIR
  3685 1658 06			        .BYTE   CMD_IDX.MKDIR           
  3686 				                                        
  3687 1659 4E 50 57 C4		        .CB     "NPWD"              ;  9 NPWD
  3688 165D 07			        .BYTE   CMD_IDX.NPWD             
  3689 				                                        
  3690 165E 4E 54 52 41 4E D3	        .CB     "NTRANS"            ; 10 NTRANS
  3691 1664 08			        .BYTE   CMD_IDX.NTRANS            
  3692 				                                        
  3693 1665 52 45 4E 41 4D C5	        .CB     "RENAME"            ; 11 RENAME
  3694 166B 09			        .BYTE   CMD_IDX.RENAME          
  3695 				                                        
  3696 166C 52 4D 44 49 D2	        .CB     "RMDIR"             ; 12 RMDIR
  3697 1671 0A			        .BYTE   CMD_IDX.RMDIR           
  3698 				                                        
  3699 1672 53 55 42 4D 49 D4	        .CB     "SUBMIT"            ; 13 SUBMIT
  3700 1678 0B			        .BYTE   CMD_IDX.SUBMIT             
  3701 				                                        
  3702 1679 54 59 50 C5		        .CB     "TYPE"              ; 14 SUBMIT
  3703 167D 0C			        .BYTE   CMD_IDX.TYPE              
  3704 				                                        
  3705 				;        .CB     "UNLOCK"            ; 15 UNLOCK
  3706 				;        .BYTE   CMD_IDX.UNLOCK            
  3707 				                                        
  3708 167E 41 55 54 4F 52 55 +         .CB     "AUTORUN"           ; 16 AUTORUN
  3709 1685 0D			        .BYTE   CMD_IDX.AUTORUN           
  3710 				                                          
  3711 1686 43 41 D2		        .CB     "CAR"               ; 17 CAR
  3712 1689 0E			        .BYTE   CMD_IDX.CAR             
  3713 				                                        
  3714 168A 43 4C D3		        .CB     "CLS"               ; 18 CLS
  3715 168D 0F			        .BYTE   CMD_IDX.CLS             
  3716 				                                       
  3717 168E 43 4F 4C C4		        .CB     "COLD"              ; 19 COLD
  3718 1692 10			        .BYTE   CMD_IDX.COLD              
  3719 				                                        
  3720 1693 48 45 4C D0		        .CB     "HELP"              ; 20 HELP
  3721 1697 11			        .BYTE   CMD_IDX.HELP               
  3722 				                                        
  3723 1698 4E 4F 42 41 53 49 +         .CB     "NOBASIC"           ; 21 NOBASIC
  3724 169F 12			        .BYTE   CMD_IDX.NOBASIC           
  3725 				                                          
  3726 16A0 40 4E 4F 53 43 52 +         .CB     "@NOSCREEN"         ; 22 @NOSCREEN
  3727 16A9 13			        .BYTE   CMD_IDX.NOSCREEN         
  3728 				                                        
  3729 16AA 50 52 49 4E D4	        .CB     "PRINT"             ; 23 PRINT
  3730 16AF 14			        .BYTE   CMD_IDX.PRINT           
  3731 				                                        
  3732 16B0 52 45 45 4E 54 45 +         .CB     "REENTER"           ; 24 REENTER
  3733 16B7 15			        .BYTE   CMD_IDX.REENTER         
  3734 				                                        
  3735 16B8 52 45 CD		        .CB     "REM"               ; 25 REM
  3736 16BB 16			        .BYTE   CMD_IDX.REM             
  3737 				                                        
  3738 16BC 52 55 CE		        .CB     "RUN"               ; 26 RUN
  3739 16BF 17			        .BYTE   CMD_IDX.RUN             
  3740 				                                        
  3741 16C0 40 53 43 52 45 45 +         .CB     "@SCREEN"           ; 27 @SCREEN
  3742 16C7 18			        .BYTE   CMD_IDX.SCREEN        
  3743 				                                      
  3744 16C8 57 41 52 CD		        .CB     "WARM"              ; 28 WARM
  3745 16CC 19			        .BYTE   CMD_IDX.WARM          
  3746 				                                      
  3747 16CD 58 45 D0		        .CB     "XEP"               ; 29 XEP
  3748 16D0 1A			        .BYTE   CMD_IDX.XEP            
  3749 				                                        
  3750 				; Aliases
  3751 16D1 43 C4		        .CB     "CD"                ; CD = NCD
  3752 16D3 00			        .BYTE   CMD_IDX.NCD           
  3753
  3754 16D4 43 57 C4		        .CB     "CWD"               ; CWD = NCD
  3755 16D7 00			        .BYTE   CMD_IDX.NCD           
  3756
  3757 16D8 45 52 41 53 C5	        .CB     "ERASE"             ; ERASE = DEL
  3758 16DD 02			        .BYTE   CMD_IDX.DEL           
  3759
  3760 16DE 45 52 C1		        .CB     "ERA"               ; ERA = DEL
  3761 16E1 02			        .BYTE   CMD_IDX.DEL           
  3762
  3763 16E2 D8			        .CB     "X"                 ; X = LOAD
  3764 16E3 03			        .BYTE   CMD_IDX.LOAD
  3765
  3766 16E4 50 57 C4		        .CB     "PWD"               ; PWD = NPWD
  3767 16E7 07			        .BYTE   CMD_IDX.NPWD             
  3768
  3769 16E8 52 45 C5		        .CB     "REE"               ; R = REENTER
  3770 16EB 15			        .BYTE   CMD_IDX.REENTER             
  3771
  3772 16EC 52 45 CE		        .CB     "REN"               ; REN = RENAME
  3773 16EF 09			        .BYTE   CMD_IDX.RENAME
  3774
  3775 16F0 53 4F 55 52 43 C5	        .CB     "SOURCE"            ; SOURCE = SUBMIT
  3776 16F6 0B			        .BYTE   CMD_IDX.SUBMIT
  3777
  3778 16F7 C0			        .CB     "@"                 ; @ = SUBMIT
  3779 16F8 0B			        .BYTE   CMD_IDX.SUBMIT
  3780
  3781 16F9 A3			        .CB     "#"                 ; # = REM
  3782 16FA 16			        .BYTE   CMD_IDX.REM
  3783
  3784 16FB A7			        .CB     "'"                 ; ' = REM
  3785 16FC 16			        .BYTE   CMD_IDX.REM
  3786
  3787 				        ; Drive Change intentionally omitted
  3788
  3789 = 00C4			COMMAND_SIZE = * - COMMAND - 1
  3790 16FD FF			        .BYTE   $FF
  3791
  3792 16FE			CMD_TAB_L:
  3793 16FE 9F			        .BYTE   <(DO_GENERIC-1)     ;  0 NCD
  3794 				;        .BYTE   <(DO_COPY-1)        ;  1 COPY
  3795 16FF 0C			        .BYTE   <(DO_DIR-1)         ;  2 DIR
  3796 1700 9F			        .BYTE   <(DO_GENERIC-1)     ;  3 DEL
  3797 1701 F6			        .BYTE   <(DO_LOAD-1)        ;  4 LOAD
  3798 				;        .BYTE   <(DO_LOCK-1)        ;  5 LOCK
  3799 1702 94			        .BYTE   <(DO_LOGIN-1)       ;  6 LOGIN
  3800 1703 C5			        .BYTE   <(DO_LPR-1)         ;  7 LPR
  3801 1704 9F			        .BYTE   <(DO_GENERIC-1)     ;  8 MKDIR
  3802 1705 CB			        .BYTE   <(DO_NPWD-1)        ;  9 NPWD
  3803 1706 0E			        .BYTE   <(DO_NTRANS-1)      ; 10 NTRANS
  3804 1707 9F			        .BYTE   <(DO_GENERIC-1)     ; 11 RENAME
  3805 1708 9F			        .BYTE   <(DO_GENERIC-1)     ; 12 RMDIR
  3806 1709 60			        .BYTE   <(DO_SUBMIT-1)      ; 13 SUBMIT
  3807 170A E5			        .BYTE   <(DO_TYPE-1)        ; 14 TYPE
  3808 				;        .BYTE   <(DO_UNLOCK-1)      ; 15 UNLOCK
  3809 170B 91			        .BYTE   <(DO_AUTORUN-1)     ; 16 AUTORUN
  3810 170C 83			        .BYTE   <(DO_CAR-1)         ; 17 CAR
  3811 170D AC			        .BYTE   <(DO_CLS-1)         ; 18 CLS
  3812 170E B5			        .BYTE   <(DO_COLD-1)        ; 19 COLD
  3813 170F B8			        .BYTE   <(DO_HELP-1)        ; 20 HELP
  3814 1710 69			        .BYTE   <(DO_NOBASIC-1)     ; 21 NOBASIC
  3815 1711 AA			        .BYTE   <(DO_NOSCREEN-1)    ; 22 NOSCREEN
  3816 1712 B6			        .BYTE   <(DO_PRINT-1)       ; 23 PRINT
  3817 1713 C4			        .BYTE   <(DO_REENTER-1)     ; 24 REENTER
  3818 1714 0E			        .BYTE   <(DO_REM-1)         ; 25 REM
  3819 1715 0F			        .BYTE   <(DO_RUN-1)         ; 26 RUN
  3820 1716 B0			        .BYTE   <(DO_SCREEN-1)      ; 27 SCREEN
  3821 1717 5D			        .BYTE   <(DO_WARM-1)        ; 28 WARM
  3822 1718 60			        .BYTE   <(DO_XEP-1)         ; 29 XEP
  3823 1719 5E			        .BYTE   <(DO_DRIVE_CHG-1)   ; 30
  3824
  3825 171A			CMD_TAB_H:
  3826 171A 0C			        .BYTE   >(DO_GENERIC-1)     ;  0 NCD
  3827 				;        .BYTE   >(DO_COPY-1)        ;  1 COPY
  3828 171B 0D			        .BYTE   >(DO_DIR-1)         ;  2 DIR
  3829 171C 0C			        .BYTE   >(DO_GENERIC-1)     ;  3 DEL
  3830 171D 0D			        .BYTE   >(DO_LOAD-1)        ;  4 LOAD
  3831 				;        .BYTE   >(DO_LOCK-1)        ;  5 LOCK
  3832 171E 10			        .BYTE   >(DO_LOGIN-1)       ;  6 LOGIN
  3833 171F 10			        .BYTE   >(DO_LPR-1)         ;  7 LPR
  3834 1720 0C			        .BYTE   >(DO_GENERIC-1)     ;  8 MKDIR
  3835 1721 10			        .BYTE   >(DO_NPWD-1)        ;  9 NPWD
  3836 1722 11			        .BYTE   >(DO_NTRANS-1)      ; 10 NTRANS
  3837 1723 0C			        .BYTE   >(DO_GENERIC-1)     ; 11 RENAME
  3838 1724 0C			        .BYTE   >(DO_GENERIC-1)     ; 12 RMDIR
  3839 1725 12			        .BYTE   >(DO_SUBMIT-1)      ; 13 SUBMIT
  3840 1726 12			        .BYTE   >(DO_TYPE-1)        ; 14 TYPE
  3841 				;        .BYTE   >(DO_UNLOCK-1)      ; 15 UNLOCK
  3842 1727 11			        .BYTE   >(DO_AUTORUN-1)     ; 16 AUTORUN
  3843 1728 13			        .BYTE   >(DO_CAR-1)         ; 17 CAR
  3844 1729 13			        .BYTE   >(DO_CLS-1)         ; 18 CLS
  3845 172A 13			        .BYTE   >(DO_COLD-1)        ; 19 COLD
  3846 172B 13			        .BYTE   >(DO_HELP-1)        ; 20 HELP
  3847 172C 14			        .BYTE   >(DO_NOBASIC-1)     ; 21 NOBASIC
  3848 172D 14			        .BYTE   >(DO_NOSCREEN-1)    ; 22 NOSCREEN
  3849 172E 14			        .BYTE   >(DO_PRINT-1)       ; 23 PRINT
  3850 172F 14			        .BYTE   >(DO_REENTER-1)     ; 24 REENTER
  3851 1730 15			        .BYTE   >(DO_REM-1)         ; 25 REM
  3852 1731 15			        .BYTE   >(DO_RUN-1)         ; 26 RUN
  3853 1732 14			        .BYTE   >(DO_SCREEN-1)      ; 27 SCREEN
  3854 1733 15			        .BYTE   >(DO_WARM-1)        ; 28 WARM
  3855 1734 15			        .BYTE   >(DO_XEP-1)         ; 29 XEP
  3856 1735 0C			        .BYTE   >(DO_DRIVE_CHG-1)   ; 30
  3857
  3858 				        ; DEVHDL TABLE FOR N:
  3859
  3860 1736 BD 07		CIOHND  .WORD   OPEN-1
  3861 1738 0B 08		        .WORD   CLOSE-1
  3862 173A 2C 08		        .WORD   GET-1
  3863 173C 8D 08		        .WORD   PUT-1
  3864 173E ED 08		        .WORD   STATUS-1
  3865 1740 53 09		        .WORD   SPEC-1
  3866
  3867 				       ; BANNERS
  3868
  3869 1742 23 46 55 4A 49 4E + BREADY  .BYTE   '#FUJINET NOS v0.5.0-alpha',EOL
  3870 175C 23 46 55 4A 49 4E + BERROR  .BYTE   '#FUJINET ERROR',EOL
  3871
  3872 				        ; MESSAGES
  3873
  3874 176B 4E 23 3F 9B		CDERR   .BYTE   'N#?',EOL
  3875
  3876 				        ; STRING CONSTANTS
  3877
  3878 176F			MISSING_FILE_STR:
  3879 176F 46 49 4C 45 3F 9B	        .BYTE   'FILE?',EOL
  3880
  3881 				        ; VARIABLES
  3882
  3883 1775 01			DOSDR       .BYTE   $01     ; DOS DRIVE
  3884 1776 01			CMD         .BYTE   $01
  3885 1777 01			CMDPRV      .BYTE   $01
  3886 1778 01			ECHO_FLG    .BYTE   $01     ; Echo batch cmds (1=enabled,0=disabled)
  3887 1779 00			AUTORUN_FLG .BYTE   $00     ; Checked at DOS entry. Runs only on first pass
  3888
  3889 177A 01			TRIP    .BYTE   $01         ; INTR FLAG
  3890 177B 00 00 00 00		RLEN    :MAXDEV .BYTE $00   ; RCV LEN
  3891 177F 00 00 00 00		ROFF    :MAXDEV .BYTE $00   ; RCV OFFSET
  3892 1783 00 00 00 00		TOFF    :MAXDEV .BYTE $00   ; TRX OFFSET
  3893 1787 01			INQDS   .BYTE   $01         ; DSTATS INQ
  3894
  3895 1788 00 00 00 00		DVS2    :MAXDEV .BYTE $00   ; DVSTAT+2 SAVE
  3896 178C 00 00 00 00		DVS3    :MAXDEV .BYTE $00   ; DVSTAT+3 SAVE
  3897
  3898 				       ; BUFFERS (PAGE ALIGNED)
  3899 1790 00 00 00 00 00 00 +         .ALIGN  $100, $00
  3900 1800			BOOTEND:
  3901
  3902 1800 00 00 00 00 00 00 + RBUF:   :$80 .BYTE $00      ; 128 bytes
  3903 1880 00 00 00 00 00 00 + TBUF:   :$80 .BYTE $00      ; 128 bytes
  3904
  3905 				; Binary loader working variables
  3906 = 1800			BAL     = RBUF
  3907 = 1801			BAH     = RBUF+1    ;
  3908 = 1880			STL     = TBUF      ; Payload Start address
  3909 = 1881			STH     = TBUF+1
  3910 = 1882			ENL     = TBUF+2    ; Payload End address
  3911 = 1883			ENH     = TBUF+3
  3912 = 1884			BLL     = TBUF+4    ; Payload Buffer Length
  3913 = 1885			BLH     = TBUF+5
  3914 = 1886			HEADL   = TBUF+6    ; Bytes read from existing cache
  3915 = 1887			HEADH   = TBUF+7
  3916 = 1888			BODYL   = TBUF+8    ; Total bytes read in contiguous 512-byte blocks
  3917 = 1889			BODYH   = TBUF+9
  3918 = 188A			TAILL   = TBUF+10   ; Bytes read from last cache
  3919 = 188B			TAILH   = TBUF+11
  3920 = 188C			BODYSZL = TBUF+12   ; # Bytes to read at a time in Body
  3921 = 188D			BODYSZH = TBUF+13
  3922 = 188E			STL2    = TBUF+14   ; Payload Start address (working var)
  3923 = 188F			STH2    = TBUF+15
  3924 = 1890			BIN_1ST = TBUF+16   ; Flag for binary loader signature (FF -> 1st pass)
  3925 = 1891			AUTORUN_QUERY_FLG = TBUF+17   ; Flag for printing contents of autorun appkey
  3926
  3927 = 1900			PGEND   = *
  3928
  3929 				; =================================================================
  3930 				; VTOC and Directory
  3931 				;
  3932
  3933 				; $10 is the added ATR-header
  3934 1900 00 00 00 00 00 00 + :($B390-*+HDR-$10) DTA $00
  3935 BA80			VTOCSTA:
  3936 BA80 02 BD 02		    DTA $02,$BD,$02
  3937 BA83			VTOCEND:
  3938
  3939 				; Fill the remaining bytes of the VTOC sector
  3940 BA83 00 00 00 00 00 00 +     :($80+VTOCSTA-VTOCEND) DTA $00
  3941
  3942 BB00			DIRSTA:
  3943 BB00 60 C3 02 04 00 30 +     DTA $60,$C3,$02,$04,$00,C"0**********"
  3944 BB10 60 C3 02 04 00 31 +     DTA $60,$C3,$02,$04,$00,C"1 FujiNet  "
  3945 BB20 60 C3 02 04 00 32 +     DTA $60,$C3,$02,$04,$00,C"2 Network  "
  3946 BB30 60 C3 02 04 00 33 +     DTA $60,$C3,$02,$04,$00,C"3   OS     "
  3947 BB40 60 C3 02 04 00 34 +     DTA $60,$C3,$02,$04,$00,C"4          "
  3948 BB50 60 C3 02 04 00 35 +     DTA $60,$C3,$02,$04,$00,C"5 v0.5.0   "
  3949 BB60 60 C3 02 04 00 36 +     DTA $60,$C3,$02,$04,$00,C"6  alpha   "
  3950 BB70 60 C3 02 04 00 37 +     DTA $60,$C3,$02,$04,$00,C"7**********"
  3951 BB80 C0			    DTA $C0
  3952 BB81			DIREND:
  3953
  3954 				; Fill the remaining sectors of the directory
  3955 BB81 00 00 00 00 00 00 +     :($400+DIRSTA-DIREND) DTA $00
  3956
  3957 				; Sectors behind directory
  3958 BF00 00 00 00 00 00 00 +     :($80*352) DTA $00
  3959
  3960 				       END
