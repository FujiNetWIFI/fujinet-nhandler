mads 2.1.1
Source: ndev.s
     1 					;; N: Device Handler
     2 					;; Compile with MADS
     3
     4 					;; Author: Thomas Cherryhomes
     5 					;;   <thom.cherryhomes@gmail.com>
     6
     7 					;; CURRENT IOCB IN ZERO PAGE
     8
     9 = 0020			ZIOCB   =     $20      ; ZP IOCB
    10 = 0020			ZICHID  =     ZIOCB    ; ID
    11 = 0021			ZICDNO  =     ZIOCB+1  ; UNIT #
    12 = 0022			ZICCOM  =     ZIOCB+2  ; COMMAND
    13 = 0023			ZICSTA  =     ZIOCB+3  ; STATUS
    14 = 0024			ZICBAL  =     ZIOCB+4  ; BUF ADR LOW
    15 = 0025			ZICBAH  =     ZIOCB+5  ; BUF ADR HIGH
    16 = 0026			ZICPTL  =     ZIOCB+6  ; PUT ADDR L
    17 = 0027			ZICPTH  =     ZIOCB+7  ; PUT ADDR H
    18 = 0028			ZICBLL  =     ZIOCB+8  ; BUF LEN LOW
    19 = 0029			ZICBLH  =     ZIOCB+9  ; BUF LEN HIGH
    20 = 002A			ZICAX1  =     ZIOCB+10 ; AUX 1
    21 = 002B			ZICAX2  =     ZIOCB+11 ; AUX 2
    22 = 002C			ZICAX3  =     ZIOCB+12 ; AUX 3
    23 = 002D			ZICAX4  =     ZIOCB+13 ; AUX 4
    24 = 002E			ZICAX5  =     ZIOCB+14 ; AUX 5
    25 = 002F			ZICAX6  =     ZIOCB+15 ; AUX 6
    26
    27 = 000C			DOSINI  =     $0C      ; DOSINI
    28
    29 = 0202			VPRCED  =     $0202   ; PROCEED VCTR
    30 = 02E7			MEMLO   =     $02E7   ; MEM LO
    31 = 02EA			DVSTAT  =     $02EA   ; 4 BYTE STATS
    32
    33 				       ; PAGE 3
    34 				       ; DEVICE CONTROL BLOCK (DCB)
    35
    36 = 0300			DCB     =     $0300   ; BASE
    37 = 0300			DDEVIC  =     DCB     ; DEVICE #
    38 = 0301			DUNIT   =     DCB+1   ; UNIT #
    39 = 0302			DCOMND  =     DCB+2   ; COMMAND
    40 = 0303			DSTATS  =     DCB+3   ; STATUS/DIR
    41 = 0304			DBUFL   =     DCB+4   ; BUF ADR L
    42 = 0305			DBUFH   =     DCB+5   ; BUF ADR H
    43 = 0306			DTIMLO  =     DCB+6   ; TIMEOUT (S)
    44 = 0307			DRSVD   =     DCB+7   ; NOT USED
    45 = 0308			DBYTL   =     DCB+8   ; BUF LEN L
    46 = 0309			DBYTH   =     DCB+9   ; BUF LEN H
    47 = 030A			DAUXL   =     DCB+10  ; AUX BYTE L
    48 = 030B			DAUXH   =     DCB+11  ; AUX BYTE H
    49
    50 = 031A			HATABS  =     $031A   ; HANDLER TBL
    51
    52 				       ; IOCB'S * 8
    53
    54 = 0340			IOCB    =     $0340   ; IOCB BASE
    55 = 0340			ICHID   =     IOCB    ; ID
    56 = 0341			ICDNO   =     IOCB+1  ; UNIT #
    57 = 0342			ICCOM   =     IOCB+2  ; COMMAND
    58 = 0343			ICSTA   =     IOCB+3  ; STATUS
    59 = 0344			ICBAL   =     IOCB+4  ; BUF ADR LOW
    60 = 0345			ICBAH   =     IOCB+5  ; BUF ADR HIGH
    61 = 0346			ICPTL   =     IOCB+6  ; PUT ADDR L
    62 = 0347			ICPTH   =     IOCB+7  ; PUT ADDR H
    63 = 0348			ICBLL   =     IOCB+8  ; BUF LEN LOW
    64 = 0349			ICBLH   =     IOCB+9  ; BUF LEN HIGH
    65 = 034A			ICAX1   =     IOCB+10 ; AUX 1
    66 = 034B			ICAX2   =     IOCB+11 ; AUX 2
    67 = 034C			ICAX3   =     IOCB+12 ; AUX 3
    68 = 034D			ICAX4   =     IOCB+13 ; AUX 4
    69 = 034E			ICAX5   =     IOCB+14 ; AUX 5
    70 = 034F			ICAX6   =     IOCB+15 ; AUX 6
    71
    72 				       ; HARDWARE REGISTERS
    73
    74 = D302			PACTL   =     $D302   ; PIA CTRL A
    75
    76 				       ; OS ROM VECTORS
    77
    78 = E456			CIOV    =     $E456   ; CIO ENTRY
    79 = E459			SIOV    =     $E459   ; SIO ENTRY
    80
    81 				       ; CONSTANTS
    82
    83 = 0071			DEVIDN  =     $71     ; SIO DEVID
    84 = 0040			DSREAD  =     $40     ; FUJI->ATARI
    85 = 0080			DSWRIT  =     $80     ; ATARI->FUJI
    86 = 0004			MAXDEV  =     4       ; # OF N: DEVS
    87 = 0088			EOF     =     $88     ; ERROR 136
    88 = 009B			EOL     =     $9B     ; EOL CHAR
    89
    90 					;; ORG HERE
    91 					ORG	$2200
    92 					
    93 					;; This is for OS/A+
    94
    95 FFFF> 2200-2591> 60		RTS			; Immediately exit
    96
    97 				;;; RESET HANDLER ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    98
    99 2201			RESET:	
   100 2201 20 FF FF			JSR	$FFFF		; Modified for original DOSINI
   101 2204 A9 FF			LDA	#$FF		; Driver end LO
   102 2206 8D E7 02			STA 	MEMLO
   103 2209 A9 FF			LDA	#$FF		; Driver end HI
   104 220B 8D E8 02			STA	MEMLO+1
   105 220E 20 2B 23			JSR	IHTBS		; Insert into HATABS
   106 2211 20 AB 22			JSR	CLALL
   107 2214 60				RTS
   108 					
   109 				;;; END RESET HANDLER ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   110
   111 				;;; INTERRUPT HANDLER ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   112
   113 2215 A9 01		INTR:	LDA	#$01		; set trip to 1
   114 2217 8D 92 25			STA	TRIP
   115 221A 68				PLA
   116 221B 40				RTI
   117 					
   118 				;;; END INTERRUPT HANDLER ;;;;;;;;;;;;;;;;;;;;;;;;
   119
   120 				;;; SUBROUTINES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   121
   122 					;; GET IOCB UNIT # INTO X
   123 					
   124 221C A6 21		GDIDX:	LDX	ZICDNO		; CURRENT IOCB UNIT #
   125 221E CA				DEX			; -1
   126 221F 60				RTS
   127
   128 					;; Poll for Status
   129
   130 2220 A5 21		POLL:	LDA	ZICDNO		; Get Unit #
   131 2222 8D 2E 22			STA	POLDCB+1	; Put into Table
   132 2225 A9 2D			LDA	#<POLDCB	; Set up STATUS POLL DCB table
   133 2227 A0 22			LDY	#>POLDCB
   134 2229 20 6C 23			JSR	DOSIOV		; And do SIOV
   135 					
   136 222C 60				RTS
   137
   138 222D 71			POLDCB:	.BYTE      DEVIDN  ; DDEVIC
   139 222E FF				.BYTE      $FF     ; DUNIT
   140 222F 53				.BYTE      'S'     ; DCOMND
   141 2230 40				.BYTE      DSREAD     ; DSTATS
   142 2231 EA 02			.WORD	   DVSTAT  ; DBUF
   143 2233 1F				.BYTE      $1F     ; DTIMLO
   144 2234 00				.BYTE      $00     ; DRESVD
   145 2235 04 00			.WORD	   4	   ; 4 bytes
   146 2237 00				.BYTE      $00     ; DAUX1
   147 2238 00				.BYTE      $00     ; DAUX2
   148
   149 					;; Save DVSTAT values
   150
   151 2239 20 1C 22		SVSTAT: JSR	GDIDX	   	; Get Unit into X
   152 223C 20 96 22			JSR	CAPRX		; Cap RX values
   153 223F AD EA 02			LDA	DVSTAT		; Get RX bytes waiting
   154 2242 9D 93 25			STA	RLEN,X		; Save RX bytes waiting
   155 2245 AD EC 02			LDA	DVSTAT+2	; Get Server Client connected/disconnected?
   156 2248 9D A0 25			STA	DVS2,X		; Save 
   157 224B AD ED 02			LDA	DVSTAT+3	; Get last error
   158 224E 9D A4 25			STA	DVS3,X		; Save
   159 2251 60				RTS
   160 					
   161 					;; Enable PROCEED interrupt
   162
   163 2252 AD 02 D3		ENPRCD:	LDA	PACTL		; Get PACTL register
   164 2255 09 01			ORA	#$01		; Enable PROCEED
   165 2257 8D 02 D3			STA	PACTL		; Store it back
   166 225A 60				RTS
   167
   168 					;; Disable PROCEED interrupt
   169 					
   170 225B AD 02 D3		DIPRCD:	LDA	PACTL		; Get PACTL register
   171 225E 29 FE			AND	#$FE		; Disable PROCEED
   172 2260 8D 02 D3			STA	PACTL		; store it back.
   173 2263 60				RTS
   174
   175 					;; Flush TX Buffer out
   176 					
   177 2264 20 1C 22		FLUSH:	JSR	GDIDX		; UNIT NUMBER into X
   178 2267 A5 21			LDA	ZICDNO		; IOCB UNIT #
   179 2269 8D 8B 22			STA	FLUDCB+1	; Put into table.
   180 226C BD 9B 25			LDA	TOFF,X		; get Transmit offset (# of bytes to send)
   181 226F F0 18			BEQ	FLDONE		; Don't do anything if TX cursor is at 0.
   182 2271 8D 92 22			STA	FLUDCB+8	; Put into Table (Len and Aux)
   183 2274 8D 94 22			STA	FLUDCB+10
   184 2277 A9 8A			LDA	#<FLUDCB	; Copy Table to DCB
   185 2279 A0 22			LDY	#>FLUDCB
   186 227B 20 6C 23			JSR	DOSIOV		; And call SIOV
   187 227E 20 1C 22			JSR	GDIDX		; Get Unit into X
   188 2281 A9 00			LDA	#$00		; Clear TOFF
   189 2283 9D 9B 25			STA	TOFF,X
   190 2286 AC 03 03			LDY	DSTATS
   191 2289 60			FLDONE:	RTS			; Done, LDY has DSTATS
   192
   193 228A 71			FLUDCB:	.BYTE      DEVIDN  	; DDEVIC
   194 228B FF				.BYTE      $FF     	; DUNIT
   195 228C 57				.BYTE      'W'     	; DCOMND
   196 228D 80				.BYTE      DSWRIT     	; DSTATS
   197 228E 28 26			.WORD      TBUF    	; DBUFL
   198 2290 1F				.BYTE      $1F     	; DTIMLO
   199 2291 00				.BYTE      $00     	; DRESVD
   200 2292 FF				.BYTE      $FF     	; DBYTL
   201 2293 00				.BYTE      $00     	; DBYTH
   202 2294 FF				.BYTE      $FF     	; DAUX1
   203 2295 00				.BYTE      $00     	; DAUX2
   204
   205 					;; Cap RX to 127 bytes (temporary routine)
   206
   207 2296 AD EB 02		CAPRX:	LDA	DVSTAT+1	; Get hi-byte
   208 2299 D0 05			BNE	CAPADJ		; Adjust if > 256 bytes
   209 229B AD EA 02			LDA	DVSTAT		; Get lo-byte
   210 229E 10 0A			BPL	CAPDON		; Exit if < 127 bytes
   211 22A0 A9 7F		CAPADJ:	LDA	#$7F		; 127 bytes
   212 22A2 8D EA 02			STA	DVSTAT		; into DVSTAT/DVSTAT+1
   213 22A5 A9 00			LDA	#$00
   214 22A7 8D EB 02			STA	DVSTAT+1
   215 22AA 60			CAPDON:	RTS			; Done
   216
   217 					;; Close all IOCBs
   218
   219 22AB A9 04		CLALL:	LDA	#MAXDEV		; Close all 4 N: devices
   220 22AD 8D 92 25			STA	TRIP		; Temporarily use trip
   221 22B0 AD 92 25		CLLP:	LDA	TRIP		; Get
   222 22B3 85 21			STA	ZICDNO		; Store into unit #
   223 22B5 20 C2 23			JSR	CLOSE		; Close Nx:
   224 22B8 CE 92 25			DEC	TRIP		; Decrement
   225 22BB AD 92 25			LDA	TRIP		; Get it
   226 22BE D0 F0			BNE	CLLP		; Loop until done.
   227 22C0 60				RTS	
   228
   229 					;; Do read from ZIOCB unit
   230
   231 22C1 20 1C 22		READ:	JSR	GDIDX	  	; unit into X
   232 22C4 A9 00			LDA	#$00		; Set 0 into
   233 22C6 9D 97 25			STA	ROFF,X		; RXD cursor.
   234 22C9 A5 21			LDA	ZICDNO		; Get Unit #
   235 22CB 8D EF 22			STA	READCB+1	; Put into Read DCB table
   236 22CE AD 93 25			LDA	RLEN		; Get RLEN (from status)
   237 22D1 F0 1A			BEQ	RDONE		; If RLEN=0 then abort read.
   238 22D3 8D F6 22			STA	READCB+8	; Store in DBYTL
   239 22D6 8D F8 22			STA	READCB+10	; Store in DAUX1
   240 22D9 A9 EE		READ2:	LDA	#<READCB	; Set up Read DCB
   241 22DB A0 22			LDY	#>READCB	; ...
   242 22DD 20 6C 23			JSR	DOSIOV		; Do SIO call
   243 22E0 AC 03 03			LDY	DSTATS		; Get DSTATS for error
   244 22E3 C0 90			CPY	#144		; Is it 144?
   245 22E5 D0 06			BNE	RDONE		; No, simply return DSTATS in Y
   246 22E7 20 20 22			JSR	POLL		; Otherwise, do a poll to get extended error
   247 22EA AC ED 02			LDY	DVSTAT+3	; And return it in Y.
   248 22ED 60			RDONE:	RTS			; Done.
   249
   250 22EE 71			READCB .BYTE     DEVIDN  	; DDEVIC
   251 22EF FF			       .BYTE     $FF     	; DUNIT
   252 22F0 52			       .BYTE     'R'     	; DCOMND
   253 22F1 40			       .BYTE     DSREAD     	; DSTATS
   254 22F2 A8 25		       .WORD	 RBUF	 	; DBUF
   255 22F4 1F			       .BYTE     $1F     	; DTIMLO
   256 22F5 00			       .BYTE     $00     	; DRESVD
   257 22F6 FF			       .BYTE     $FF     	; DBYTL
   258 22F7 00			       .BYTE     $00     	; DBYTH
   259 22F8 FF			       .BYTE     $FF     	; DAUX1
   260 22F9 00			       .BYTE     $00     	; DAUX2
   261 					
   262 				;;; END SUBROUTINES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   263 					
   264 				;;; DEVICE HANDLER TABLE ;;;;;;;;;;;;;;;;;;;;;;;;;
   265
   266 22FA 84 23		DEVHDL:	.WORD	OPEN-1
   267 22FC C1 23			.WORD	CLOSE-1
   268 22FE 51 24			.WORD	GET-1
   269 2300 AA 24			.WORD	PUT-1
   270 2302 C2 24			.WORD	STATUS-1
   271 2304 EF 24			.WORD	SPECIAL-1
   272 					
   273 				;;; HANDLER RUNAD HERE ;;;;;;;;;;;;;;;;;;;;;;;;;;;
   274 					
   275 2306 A5 0C		START:	LDA	DOSINI
   276 2308 8D 02 22			STA	RESET+1
   277 230B A5 0D			LDA	DOSINI+1
   278 230D 8D 03 22			STA	RESET+2
   279 2310 A9 01			LDA	#<RESET
   280 2312 85 0C			STA	DOSINI
   281 2314 A9 22			LDA	#>RESET
   282 2316 85 0D			STA	DOSINI+1
   283 2318 A9 A8			LDA	#<HANDLEREND
   284 231A 8D E7 02			STA	MEMLO
   285 231D 8D 05 22			STA	RESET+4
   286 2320 A9 26			LDA	#>HANDLEREND
   287 2322 8D E8 02			STA	MEMLO+1
   288 2325 8D 0A 22			STA	RESET+9
   289 2328 20 AB 22			JSR	CLALL		; Close all
   290 					
   291 				;;; Insert Handler entry into HATABS ;;;;;;;;;;;
   292
   293 232B A0 00		IHTBS:	LDY	#$00		; Start at beginning of HATABS
   294 232D B9 1A 03		IH1:	LDA	HATABS,Y
   295 2330 F0 0B			BEQ	HFND		; Did we find a blank ($00) entry?
   296 2332 C9 4E			CMP	#'N'		; or did we find our existing 'N' entry?
   297 2334 F0 07			BEQ	HFND		; If so, insert our entry here.
   298 2336 C8				INY			; Otherwise, scoot forward to next entry.
   299 2337 C8				INY			
   300 2338 C8				INY
   301 2339 C0 21			CPY	#11*3		; Are we at the end of the table?
   302 233B 90 F0			BCC	IH1		; Check again.
   303
   304 					;; We found a slot, insert it in.
   305
   306 233D A9 4E		HFND:	LDA	#'N'		; We are the N: device
   307 233F 99 1A 03			STA	HATABS,Y	; first byte in our entry
   308 2342 A9 FA			LDA	#<DEVHDL	; Get address of our handler table
   309 2344 99 1B 03			STA	HATABS+1,Y	; and put it in Hatabs
   310 2347 A9 22			LDA	#>DEVHDL
   311 2349 99 1C 03			STA	HATABS+2,Y
   312 					
   313 					;; And vector in PROCEED.
   314
   315 234C A9 15		VPRCD:	LDA	#<INTR		; Get Addr of interrupt handler
   316 234E 8D 02 02			STA	VPRCED		; Store it in PROCEED vector
   317 2351 A9 22			LDA	#>INTR
   318 2353 8D 03 02			STA	VPRCED+1
   319 					
   320 					;; We're done, back to DOS.
   321
   322 2356 60				RTS
   323
   324 				;;; INDICATE SUCCESS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   325
   326 2357 A0 01		SUCC:	LDY	#$01 		; Indicate success
   327 2359 60				RTS			; Back to caller.
   328
   329 				;;; CLEAR BUFFERS FOR UNIT X ;;;;;;;;;;;;;;;;;;;;
   330 					
   331 235A A9 00		CLRBUF:	LDA	#$00
   332 235C 9D 93 25			STA	RLEN,X
   333 235F 9D 9B 25			STA	TOFF,X
   334 2362 9D 97 25			STA	ROFF,X
   335 2365 9D A0 25			STA	DVS2,X
   336 2368 9D A4 25			STA	DVS3,X
   337 236B 60				RTS
   338 					
   339 				;;; COPY TABLE TO DCB AND DO SIO CALL ;;;;;;;;;;;
   340
   341 236C 8D 75 23		DOSIOV: STA	DODCBL+1	; Set source address
   342 236F 8C 76 23			STY	DODCBL+2
   343 2372 A0 0C			LDY	#$0C		; 12 bytes
   344 2374 B9 FF FF		DODCBL	LDA	$FFFF,Y		; Changed above.
   345 2377 99 00 03			STA	DCB,Y		; To DCB table
   346 237A 88				DEY			; Count down
   347 237B 10 F7			BPL	DODCBL		; Until done
   348
   349 237D			SIOVDST:	
   350 237D 20 59 E4			JSR	SIOV		; Call SIOV
   351 2380 AC 03 03			LDY	DSTATS		; Get STATUS in Y
   352 2383 98				TYA			; Copy it into A
   353 2384 60				RTS			; Done
   354 					
   355 				;;; OPEN ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   356
   357 					;; Fill in the OPEN table
   358 					
   359 2385 20 1C 22		OPEN:   JSR	GDIDX		; Set IOCB OFFSET TO UNIT #
   360 2388 20 5A 23			JSR	CLRBUF		; Clear Buffers
   361 238B A5 21			LDA	ZICDNO		; GET Desired unit #
   362 238D 8D B7 23			STA	OPNDCB+1	; Store in open table
   363 2390 A5 24			LDA	ZICBAL		; Get desired buffer LO
   364 2392 8D BA 23			STA	OPNDCB+4	; Store in open table
   365 2395 A5 25			LDA	ZICBAH		; Get desired buffer HI
   366 2397 8D BB 23			STA	OPNDCB+5	; Store in open table
   367 239A A5 2A			LDA	ZICAX1		; Get requested Aux1
   368 239C 8D C0 23			STA	OPNDCB+10	; Store in open table
   369 239F A5 2B			LDA	ZICAX2		; Get requested Aux2
   370 23A1 8D C1 23			STA	OPNDCB+11	; Store in open table
   371
   372 					;; Do the SIOV call
   373 					
   374 23A4 A9 B6			LDA	#<OPNDCB
   375 23A6 A0 23			LDY	#>OPNDCB
   376 23A8 20 6C 23			JSR	DOSIOV
   377
   378 					;; Return DSTATS in Y, unless 144, then get ext err.
   379
   380 23AB C0 90			CPY	#144		; Did we get an ERROR- 144?
   381 23AD D0 06			BNE	OPDONE		; Nope, keep DSTATS in Y
   382
   383 					;; We got a 144, get error from STATUS call
   384 23AF 20 20 22			JSR	POLL		; Do Status poll
   385 23B2 AC ED 02			LDY	DVSTAT+3	; Get error code
   386
   387 23B5 60			OPDONE:	RTS
   388
   389 					;; OPEN DCB TABLE
   390
   391 23B6			OPNDCB:
   392 23B6 71				.BYTE      DEVIDN  	; DDEVIC
   393 23B7 FF				.BYTE      $FF     	; DUNIT
   394 23B8 4F				.BYTE      'O'     	; DCOMND
   395 23B9 80				.BYTE      DSWRIT     	; DSTATS
   396 23BA FF				.BYTE      $FF     	; DBUFL
   397 23BB FF				.BYTE      $FF     	; DBUFH
   398 23BC 1F				.BYTE      $1F     	; DTIMLO
   399 23BD 00				.BYTE      $00     	; DRESVD
   400 23BE 00				.BYTE      $00     	; DBYTL
   401 23BF 01				.BYTE      $01     	; DBYTH
   402 23C0 FF				.BYTE      $FF     	; DAUX1
   403 23C1 FF				.BYTE      $FF     	; DAUX2
   404
   405 				;;; CLOSE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   406
   407 23C2 20 5B 22		CLOSE:	JSR	DIPRCD		; Disable PROCEED
   408 23C5 20 64 22			JSR	FLUSH		; do PUT flush if needed.
   409 23C8 20 5A 23			JSR	CLRBUF		; Clear buffer pointers
   410 23CB A5 21			LDA	ZICDNO		; Unit #
   411 23CD 8D DB 23			STA	CLODCB+1	; Put into table
   412 23D0 A9 DA			LDA	#<CLODCB	; Close DCB table
   413 23D2 A0 23			LDY	#>CLODCB
   414 23D4 20 6C 23			JSR	DOSIOV		; Do SIOV
   415 23D7 4C 57 23			JMP	SUCC		; Always return success
   416
   417 23DA 71			CLODCB .BYTE	DEVIDN		; DDEVIC
   418 23DB FF			       .BYTE	$FF		; DUNIT
   419 23DC 43			       .BYTE	'C'		; DCOMND
   420 23DD 00			       .BYTE	$00		; DSTATS
   421 23DE 00			       .BYTE	$00		; DBUFL
   422 23DF 00			       .BYTE	$00		; DBUFH
   423 23E0 1F			       .BYTE	$1F		; DTIMLO
   424 23E1 00			       .BYTE	$00		; DRESVD
   425 23E2 00			       .BYTE	$00		; DBYTL
   426 23E3 00			       .BYTE	$00		; DBYTH
   427 23E4 00			       .BYTE	$00		; DAUX1
   428 23E5 00			       .BYTE	$00		; DAUX2
   429
   430 				;;; GET ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   431
   432 					;; Called to do burst read from GETB
   433 					
   434 23E6 A5 21		GETBR:	LDA	ZICDNO		; Get requested unit #
   435 23E8 8D EF 22			STA	READCB+1	; Store into DUNIT portion of table.
   436 23EB A5 24			LDA	ZICBAL		; Get requested dest buffer from IOCB
   437 23ED 8D F2 22			STA	READCB+4	; ...and put into DCB
   438 23F0 A5 25			LDA	ZICBAH		; ...
   439 23F2 8D F3 22			STA	READCB+5	; ...
   440 23F5 A5 28			LDA	ZICBLL		; Get Requested Length
   441 23F7 8D F6 22			STA	READCB+8	; and stuff into DCB as DBYT/DAUX
   442 23FA 8D F8 22			STA	READCB+10	; ...
   443 23FD A5 29			LDA	ZICBLH		; ...
   444 23FF 8D F7 22			STA	READCB+9	; ...
   445 2402 8D F9 22			STA	READCB+11	; ...
   446 2405 A9 EE			LDA	#<READCB	; Set up DCB
   447 2407 A0 22			LDY	#>READCB	; ...
   448 2409 20 6C 23			JSR	DOSIOV		; and do SIOV call
   449 240C 60				RTS			; Back to GETB.
   450
   451 					;; Called when burst mode is requested
   452 					
   453 240D 20 E6 23		GETB:	JSR	GETBR		; Do the SIO call.
   454 2410 AC 03 03			LDY	DSTATS 		; Get error (come back here later and fill this out)
   455 2413 10 0D			BPL	GETBS		; If no error, continue
   456 2415 C0 90			CPY	#144		; Extended error?
   457 2417 F0 06			BEQ	GETB2		; Nope, loop to done
   458 2419 20 39 22			JSR	SVSTAT		; Get status
   459 241C AC ED 02			LDY	DVSTAT+3	; Get extended error
   460 241F 4C A9 24		GETB2:	JMP	GETDNE		; Leave.
   461
   462 					;; Adjust buffer length to length-1
   463
   464 2422 38			GETBS:	SEC			; Set up for subtraction
   465 2423 A5 28			LDA	ZICBLL		; Get length
   466 2425 E9 01			SBC	#01		; Subtract 1
   467 2427 85 28			STA	ZICBLL		; Store back
   468 2429 90 02			BCC	GETBA		; go to the add stage, if done
   469 242B C6 29			DEC	ZICBLH		; We need to decrement the msb too
   470
   471 					;; Use buffer length to adjust address
   472
   473 242D 18			GETBA:	CLC			; Set up for addition
   474 242E A5 24			LDA	ZICBAL		; Get Low byte of buffer address
   475 2430 65 28			ADC	ZICBLL		; Adjust by now adjusted length
   476 2432 85 24			STA	ZICBAL		; And store it back
   477 2434 A5 25			LDA	ZICBAH		; Get High byte of buffer address
   478 2436 65 29			ADC	ZICBLH		; Adjust by now adjusted length
   479 2438 85 25			STA	ZICBAH		; And store it back
   480
   481 					;; Now reset length to 1, for the last trip through CIO
   482
   483 243A 20 1C 22		GETBL:	JSR	GDIDX		; Put IOCB into X
   484 243D A9 01			LDA	#$01		; ZIOCB buffer length now 1
   485 243F A8				TAY			; Stuff into Y (for later)
   486 2440 85 28			STA	ZICBLL		; ...
   487 2442 9D 93 25			STA	RLEN,X		; and alter RLEN
   488 2445 A9 00			LDA	#$00		; ...
   489 2447 9D 97 25			STA	ROFF,X		; and alter ROFF
   490 244A 85 29			STA	ZICBLH		; ...
   491
   492 					;; Stuff the one byte left into the start of the rcv buffer
   493 244C B1 24			LDA	(ZICBAL),Y	; Get next byte (y=1)
   494 244E 8D A8 25			STA	RBUF		; and pop into buffer.
   495 2451 60				RTS			; And we're done here.
   496
   497 					;; GET entry point for CIO
   498 					
   499 2452 A5 29		GET:	LDA	ZICBLH
   500 2454 D0 B7			BNE	GETB
   501 2456 A5 28			LDA	ZICBLL
   502 2458 D0 B3			BNE	GETB		; Go to burst
   503 245A 20 1C 22			JSR	GDIDX		; Unit into X
   504 245D BD 93 25			LDA	RLEN,X		; Get current RX len from last STATUS
   505 2460 D0 29			BNE	GETDRN		; If RLEN > 0 then drain.
   506
   507 					;; Otherwise, we wait for something to happen.
   508
   509 2462 20 52 22		GETWAI:	JSR	ENPRCD		; Enable Proceed
   510 2465 AD 92 25			LDA	TRIP		; Did trip change?
   511 2468 F0 F8			BEQ	GETWAI		; Nope, not yet...
   512
   513 					;; Something happened, try to poll for data.
   514
   515 246A 20 20 22			JSR	POLL		; Do Status Poll
   516 246D 20 39 22			JSR	SVSTAT		; Save Status
   517 2470 20 C1 22			JSR	READ		; Do read
   518
   519 					;; If RLEN=0 then determine if error.
   520
   521 2473 AD EA 02			LDA	DVSTAT		; Get RLEN Again
   522 2476 D0 13			BNE	GETDRN		; If RLEN > 1, then drain.
   523 2478 AC ED 02			LDY	DVSTAT+3	; Get ext err
   524 247B C0 88			CPY	#136		; EOF?
   525 247D F0 2A			BEQ	GETDNE		; Yes, return it.
   526 247F AC 03 03			LDY	DSTATS		; Else, get DSTATS from status/read.
   527 2482 C0 90			CPY	#144		; is it 144?
   528 2484 D0 23			BNE	GETDNE		; Nope, simply return it in Y, done.
   529 2486 AC ED 02			LDY	DVSTAT+3	; Get Extended error
   530 2489 D0 1E			BNE	GETDNE		; Done.
   531
   532 					;; Drain
   533 					
   534 248B 20 5B 22		GETDRN:	JSR	DIPRCD		; Disable PROCEED
   535 248E 20 1C 22			JSR	GDIDX		; Get Unit into X again
   536 2491 DE 93 25			DEC	RLEN,X		; Decrement length
   537 2494 BC 97 25			LDY	ROFF,X		; Get Current Offset into X
   538 2497 B9 A8 25			LDA	RBUF,Y		; Get next character
   539 249A FE 97 25			INC	ROFF,X		; Increment cursor
   540 249D A8				TAY			; Store in Y for a moment
   541
   542 					;; If RX buffer empty, turn off trip.
   543
   544 249E BD 93 25			LDA	RLEN,X		; Get RLEN
   545 24A1 D0 03			BNE	GETDN2		; some left, just go done with success
   546 24A3 8D 92 25			STA	TRIP		; Otherwise store 0 into trip
   547 					
   548 24A6 98			GETDN2:	TYA			; Bring back char into A
   549 24A7 A0 01			LDY	#$01		; 
   550 24A9 98			GETDNE: TYA			; Restore CPU status.
   551 24AA 60				RTS
   552 					
   553 				;;; PUT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   554
   555 24AB 20 1C 22		PUT:	JSR	GDIDX		; Get Unit # into X
   556 24AE BC 9B 25			LDY	TOFF,X		; Get TX cursor
   557 24B1 99 28 26			STA	TBUF,Y		; Put char into buffer ptd by cursor
   558
   559 24B4 FE 9B 25			INC	TOFF,X		; Increment TX cursor
   560
   561 					;; Do a FLUSH if EOL or buffer full
   562
   563 24B7 C9 9B			CMP	#EOL		; EOL?
   564 24B9 F0 04			BEQ	PFLUSH		; Do flush
   565 24BB C0 7F			CPY	#$7F		; At end of buffer?
   566 24BD D0 03			BNE	PUTDON		; Nope, done.
   567 24BF 20 64 22		PFLUSH:	JSR	FLUSH		; Do Flush.
   568 24C2 60			PUTDON:	RTS			; We're done.
   569 					
   570 				;;; STATUS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   571
   572 24C3 20 52 22		STATUS:	JSR	ENPRCD		; Enable PROCEED.
   573
   574 					;; Return cached value if we still have data in RX
   575
   576 24C6 20 1C 22			JSR	GDIDX		; Unit into X
   577 24C9 BD 93 25			LDA	RLEN,X		; Get RX len
   578 24CC D0 0E			BNE	STRETC		; Return cached value if RLEN > 0
   579
   580 24CE AD 92 25			LDA	TRIP		; Get TRIP?
   581 24D1 F0 09			BEQ	STRETC		; No trip? Return cached.
   582
   583 24D3 20 20 22			JSR	POLL		; RLEN = 0, do poll.
   584 24D6 20 39 22			JSR	SVSTAT		; Save DVSTAT values
   585 24D9 20 C1 22			JSR	READ		; Do read.
   586 					
   587 24DC BD 93 25		STRETC:	LDA	RLEN,X		; Get Saved DVSTAT+0 val
   588 24DF 8D EA 02			STA	DVSTAT		; Store into DVSTAT
   589 24E2 BD A0 25			LDA	DVS2,X		; Get Saved DVSTAT+2 val
   590 24E5 8D EC 02			STA	DVSTAT+2	; Store
   591 24E8 BD A4 25			LDA	DVS3,X		; Get Saved DVSTAT+3 val
   592 24EB 8D ED 02			STA	DVSTAT+3
   593 24EE A8				TAY			; copy it into Y for error output.
   594 					
   595 24EF 60				RTS			; Done.	
   596 					
   597 				;;; SPECIAL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   598
   599 24F0			SPECIAL:
   600 					
   601 					;; Clear Trip
   602
   603 24F0 A9 00			LDA	#$00
   604 24F2 8D 92 25			STA	TRIP
   605
   606 					;; Handle Local Commands
   607
   608 24F5 A5 22			LDA	ZICCOM
   609 24F7 C9 0F			CMP	#$0F		; 15 = FLUSH
   610 24F9 D0 08			BNE	SPQ		; No. Handle protocol commands
   611 24FB 20 64 22			JSR	FLUSH		; Yes. Do flush.
   612 24FE A0 01			LDY	#$01		; Flush always successful
   613 2500 4C 85 25			JMP	SPCDNE		; We're done.
   614
   615 					;; Handle Protocol commands, do INQDS Query
   616
   617 2503 A9 FF		SPQ:	LDA	#$FF		; Set INQDS
   618 2505 8D 88 25			STA	SPEDCB+2		; To DCOMND
   619 2508 A5 21			LDA	ZICDNO		; Get Unit #
   620 250A 8D 87 25			STA	SPEDCB+1	; Store in table
   621 250D A5 22			LDA	ZICCOM		; Get Command
   622 250F 8D 90 25			STA	SPEDCB+10	; Put in AUX1 for query
   623 2512 A9 01			LDA	#$01		; 1 byte
   624 2514 8D 8E 25			STA	SPEDCB+8	;
   625 2517 A9 00			LDA	#$00		;
   626 2519 8D 8F 25			STA	SPEDCB+9	;
   627 251C A9 9F			LDA	#<INQDS		; Stora INQDS address
   628 251E 8D 8A 25			STA	SPEDCB+4	; ...
   629 2521 A9 25			LDA	#>INQDS		; ...
   630 2523 8D 8B 25			STA	SPEDCB+5
   631 2526 A9 40			LDA	#$40		; <-Atari
   632 2528 8D 89 25			STA	SPEDCB+3
   633 252B A9 86			LDA	#<SPEDCB	; Set up SPECIAL DCB TABLE
   634 252D A0 25			LDY	#>SPEDCB	;
   635 252F 20 6C 23			JSR	DOSIOV		; Do Query
   636 2532 AC 03 03			LDY	DSTATS		; Get DSTATS
   637 2535 30 4E			BMI	SPCDNE		; SIO error, return in Y. There is no ext err.
   638
   639 					;; We got a query, if it's $FF, return unimplemented.
   640 2537 AD 9F 25			LDA	INQDS		; Get the Returned DSTATS value from inquiry
   641 253A C9 FF			CMP	#$FF		; Is it $FF ?
   642 253C D0 05			BNE	SPDO		; Nope, let's do it.
   643 253E A0 92			LDY	#146		; ERROR- 146  Unimplemented Command
   644 2540 4C 85 25			JMP	SPCDNE		; Done.
   645
   646 					;; Do the Special, get all IOCB params, push onto stack
   647 					
   648 2543 A5 21		SPDO:	LDA	ZICDNO		; Unit #
   649 2545 8D 87 25			STA	SPEDCB+1
   650 2548 A5 22			LDA	ZICCOM		; Command
   651 254A 8D 88 25			STA	SPEDCB+2
   652 254D AD 9F 25			LDA	INQDS		; Result of Inquiry
   653 2550 8D 89 25			STA	SPEDCB+3
   654 2553 A5 24			LDA	ZICBAL		; Ptr to passed in devicespec
   655 2555 8D 8A 25			STA	SPEDCB+4
   656 2558 A5 25			LDA	ZICBAH		; 
   657 255A 8D 8B 25			STA	SPEDCB+5
   658 255D A9 00			LDA #$00
   659 255F 8D 8E 25			STA SPEDCB+8
   660 2562 A9 01			LDA #$01
   661 2564 8D 8F 25			STA SPEDCB+9
   662 2567 A5 2A			LDA	ZICAX1		; Aux1
   663 2569 8D 90 25			STA	SPEDCB+10
   664 256C A5 2B			LDA	ZICAX2		; Aux2
   665 256E 8D 91 25			STA	SPEDCB+11
   666 2571 A9 86			LDA	#<SPEDCB
   667 2573 A0 25			LDY	#>SPEDCB
   668 2575 20 6C 23			JSR	DOSIOV
   669
   670 					;; Get error and return extended if needed.
   671
   672 2578 AC 03 03			LDY	DSTATS		; Get DSTATS
   673 257B C0 90			CPY	#144		; Is it 144?
   674 257D D0 06			BNE	SPCDNE		; Nope, just return it.
   675
   676 257F 20 20 22			JSR	POLL		; Get status, for error
   677 2582 AC ED 02			LDY	DVSTAT+3	; Get extended error.
   678 					
   679 2585 60			SPCDNE:	RTS
   680
   681 2586 71			SPEDCB .BYTE      DEVIDN  ; DDEVIC
   682 2587 FF			       .BYTE      $FF     ; DUNIT
   683 2588 FF			       .BYTE      $FF     ; DCOMND ; inq
   684 2589 40			       .BYTE      DSREAD     ; DSTATS
   685 258A 9F 25		       .WORD      INQDS    ; DBUFL
   686 258C 1F			       .BYTE      $1F     ; DTIMLO
   687 258D 00			       .BYTE      $00     ; DRESVD
   688 258E 01			       .BYTE      $01     ; DBYTL
   689 258F 00			       .BYTE      $00     ; DBYTH
   690 2590 FF			       .BYTE      $FF     ; DAUX1
   691 2591 FF			       .BYTE      $FF     ; DAUX2	
   692 					
   693 					;; End of Handler
   694
   695 				;;; VARIABLES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   696
   697 = 2592			TRIP	.ds	1		; Interrupt Tripped?
   698 = 2593			RLEN	.ds	MAXDEV		; RXD Len
   699 = 2597			ROFF	.ds	MAXDEV		; RXD offset cursor
   700 = 259B			TOFF	.ds	MAXDEV		; TXD offset cursor
   701 = 259F			INQDS	.ds	1		; DSTATS to return in inquiry
   702 = 25A0			DVS2	.ds	MAXDEV		; DVSTAT+2 SAVE
   703 = 25A4			DVS3	.ds	MAXDEV		; DVSTAT+3 SAVE
   704
   705 = 25A8			RBUF	.ds	128		; RXD buffer
   706 = 2628			TBUF	.ds	128		; TXD buffer
   707 					
   708 = 26A8			HANDLEREND	= *
   709
   710 02E0-02E1> 06 23			RUN	START
   711 					END
