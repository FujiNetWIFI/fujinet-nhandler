mads 2.1.1
Source: ndev.s
     1 					;; N: Device Handler
     2 					;; Compile with MADS
     3
     4 					;; Author: Thomas Cherryhomes
     5 					;;   <thom.cherryhomes@gmail.com>
     6
     7 					;; CURRENT IOCB IN ZERO PAGE
     8
     9 = 0020			ZIOCB   =     $20      ; ZP IOCB
    10 = 0020			ZICHID  =     ZIOCB    ; ID
    11 = 0021			ZICDNO  =     ZIOCB+1  ; UNIT #
    12 = 0022			ZICCOM  =     ZIOCB+2  ; COMMAND
    13 = 0023			ZICSTA  =     ZIOCB+3  ; STATUS
    14 = 0024			ZICBAL  =     ZIOCB+4  ; BUF ADR LOW
    15 = 0025			ZICBAH  =     ZIOCB+5  ; BUF ADR HIGH
    16 = 0026			ZICPTL  =     ZIOCB+6  ; PUT ADDR L
    17 = 0027			ZICPTH  =     ZIOCB+7  ; PUT ADDR H
    18 = 0028			ZICBLL  =     ZIOCB+8  ; BUF LEN LOW
    19 = 0029			ZICBLH  =     ZIOCB+9  ; BUF LEN HIGH
    20 = 002A			ZICAX1  =     ZIOCB+10 ; AUX 1
    21 = 002B			ZICAX2  =     ZIOCB+11 ; AUX 2
    22 = 002C			ZICAX3  =     ZIOCB+12 ; AUX 3
    23 = 002D			ZICAX4  =     ZIOCB+13 ; AUX 4
    24 = 002E			ZICAX5  =     ZIOCB+14 ; AUX 5
    25 = 002F			ZICAX6  =     ZIOCB+15 ; AUX 6
    26
    27 = 000C			DOSINI  =     $0C      ; DOSINI
    28
    29 = 0202			VPRCED  =     $0202   ; PROCEED VCTR
    30 = 02E7			MEMLO   =     $02E7   ; MEM LO
    31 = 02EA			DVSTAT  =     $02EA   ; 4 BYTE STATS
    32
    33 				       ; PAGE 3
    34 				       ; DEVICE CONTROL BLOCK (DCB)
    35
    36 = 0300			DCB     =     $0300   ; BASE
    37 = 0300			DDEVIC  =     DCB     ; DEVICE #
    38 = 0301			DUNIT   =     DCB+1   ; UNIT #
    39 = 0302			DCOMND  =     DCB+2   ; COMMAND
    40 = 0303			DSTATS  =     DCB+3   ; STATUS/DIR
    41 = 0304			DBUFL   =     DCB+4   ; BUF ADR L
    42 = 0305			DBUFH   =     DCB+5   ; BUF ADR H
    43 = 0306			DTIMLO  =     DCB+6   ; TIMEOUT (S)
    44 = 0307			DRSVD   =     DCB+7   ; NOT USED
    45 = 0308			DBYTL   =     DCB+8   ; BUF LEN L
    46 = 0309			DBYTH   =     DCB+9   ; BUF LEN H
    47 = 030A			DAUXL   =     DCB+10  ; AUX BYTE L
    48 = 030B			DAUXH   =     DCB+11  ; AUX BYTE H
    49
    50 = 031A			HATABS  =     $031A   ; HANDLER TBL
    51
    52 				       ; IOCB'S * 8
    53
    54 = 0340			IOCB    =     $0340   ; IOCB BASE
    55 = 0340			ICHID   =     IOCB    ; ID
    56 = 0341			ICDNO   =     IOCB+1  ; UNIT #
    57 = 0342			ICCOM   =     IOCB+2  ; COMMAND
    58 = 0343			ICSTA   =     IOCB+3  ; STATUS
    59 = 0344			ICBAL   =     IOCB+4  ; BUF ADR LOW
    60 = 0345			ICBAH   =     IOCB+5  ; BUF ADR HIGH
    61 = 0346			ICPTL   =     IOCB+6  ; PUT ADDR L
    62 = 0347			ICPTH   =     IOCB+7  ; PUT ADDR H
    63 = 0348			ICBLL   =     IOCB+8  ; BUF LEN LOW
    64 = 0349			ICBLH   =     IOCB+9  ; BUF LEN HIGH
    65 = 034A			ICAX1   =     IOCB+10 ; AUX 1
    66 = 034B			ICAX2   =     IOCB+11 ; AUX 2
    67 = 034C			ICAX3   =     IOCB+12 ; AUX 3
    68 = 034D			ICAX4   =     IOCB+13 ; AUX 4
    69 = 034E			ICAX5   =     IOCB+14 ; AUX 5
    70 = 034F			ICAX6   =     IOCB+15 ; AUX 6
    71
    72 				       ; HARDWARE REGISTERS
    73
    74 = D302			PACTL   =     $D302   ; PIA CTRL A
    75
    76 				       ; OS ROM VECTORS
    77
    78 = E456			CIOV    =     $E456   ; CIO ENTRY
    79 = E459			SIOV    =     $E459   ; SIO ENTRY
    80
    81 				       ; CONSTANTS
    82
    83 = 0071			DEVIDN  =     $71     ; SIO DEVID
    84 = 0040			DSREAD  =     $40     ; FUJI->ATARI
    85 = 0080			DSWRIT  =     $80     ; ATARI->FUJI
    86 = 0004			MAXDEV  =     4       ; # OF N: DEVS
    87 = 0088			EOF     =     $88     ; ERROR 136
    88 = 009B			EOL     =     $9B     ; EOL CHAR
    89
    90 					;; ORG HERE
    91 					ORG	$2200
    92 					
    93 					;; This is for OS/A+
    94
    95 FFFF> 2200-25B5> 60		RTS			; Immediately exit
    96
    97 				;;; RESET HANDLER ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    98
    99 2201			RESET:	
   100 2201 20 FF FF			JSR	$FFFF		; Modified for original DOSINI
   101 2204 A9 FF			LDA	#$FF		; Driver end LO
   102 2206 8D E7 02			STA 	MEMLO
   103 2209 A9 FF			LDA	#$FF		; Driver end HI
   104 220B 8D E8 02			STA	MEMLO+1
   105 220E 20 A4 23			JSR	IHTBS		; Insert into HATABS
   106 2211 20 B0 22			JSR	CLALL
   107 2214 60				RTS
   108 					
   109 				;;; END RESET HANDLER ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   110
   111 				;;; INTERRUPT HANDLER ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   112
   113 2215 A9 01		INTR:	LDA	#$01		; set trip to 1
   114 2217 8D B6 25			STA	TRIP
   115 221A 68				PLA
   116 221B 40				RTI
   117 					
   118 				;;; END INTERRUPT HANDLER ;;;;;;;;;;;;;;;;;;;;;;;;
   119
   120 				;;; SUBROUTINES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   121
   122 					;; GET IOCB UNIT # INTO X
   123 					
   124 221C A6 21		GDIDX:	LDX	ZICDNO		; CURRENT IOCB UNIT #
   125 221E CA				DEX			; -1
   126 221F 60				RTS
   127
   128 					;; Poll for Status
   129
   130 2220 A5 21		POLL:	LDA	ZICDNO		; Get Unit #
   131 2222 8D 2E 22			STA	POLDCB+1	; Put into Table
   132 2225 A9 2D			LDA	#<POLDCB	; Set up STATUS POLL DCB table
   133 2227 A0 22			LDY	#>POLDCB
   134 2229 20 E5 23			JSR	DOSIOV		; And do SIOV
   135 					
   136 222C 60				RTS
   137
   138 222D 71			POLDCB:	.BYTE      DEVIDN  ; DDEVIC
   139 222E FF				.BYTE      $FF     ; DUNIT
   140 222F 53				.BYTE      'S'     ; DCOMND
   141 2230 40				.BYTE      DSREAD     ; DSTATS
   142 2231 EA 02			.WORD	   DVSTAT  ; DBUF
   143 2233 1F				.BYTE      $1F     ; DTIMLO
   144 2234 00				.BYTE      $00     ; DRESVD
   145 2235 04 00			.WORD	   4	   ; 4 bytes
   146 2237 00				.BYTE      $00     ; DAUX1
   147 2238 00				.BYTE      $00     ; DAUX2
   148
   149 					;; Save DVSTAT values
   150
   151 2239 20 1C 22		SVSTAT: JSR	GDIDX	   	; Get Unit into X
   152 223C AD CC 25			LDA	BURST		; Are we in burst mode?
   153 223F D0 03			BNE	SVSTAS		; Yes, do not cap values, just save them.
   154 2241 20 9B 22			JSR	CAPRX		; Cap RX values
   155 2244 AD EA 02		SVSTAS:	LDA	DVSTAT		; Get RX bytes waiting
   156 2247 9D B7 25			STA	RLEN,X		; Save RX bytes waiting
   157 224A AD EC 02			LDA	DVSTAT+2	; Get Server Client connected/disconnected?
   158 224D 9D C4 25			STA	DVS2,X		; Save 
   159 2250 AD ED 02			LDA	DVSTAT+3	; Get last error
   160 2253 9D C8 25			STA	DVS3,X		; Save
   161 2256 60				RTS
   162 					
   163 					;; Enable PROCEED interrupt
   164
   165 2257 AD 02 D3		ENPRCD:	LDA	PACTL		; Get PACTL register
   166 225A 09 01			ORA	#$01		; Enable PROCEED
   167 225C 8D 02 D3			STA	PACTL		; Store it back
   168 225F 60				RTS
   169
   170 					;; Disable PROCEED interrupt
   171 					
   172 2260 AD 02 D3		DIPRCD:	LDA	PACTL		; Get PACTL register
   173 2263 29 FE			AND	#$FE		; Disable PROCEED
   174 2265 8D 02 D3			STA	PACTL		; store it back.
   175 2268 60				RTS
   176
   177 					;; Flush TX Buffer out
   178 					
   179 2269 20 1C 22		FLUSH:	JSR	GDIDX		; UNIT NUMBER into X
   180 226C A5 21			LDA	ZICDNO		; IOCB UNIT #
   181 226E 8D 90 22			STA	FLUDCB+1	; Put into table.
   182 2271 BD BF 25			LDA	TOFF,X		; get Transmit offset (# of bytes to send)
   183 2274 F0 18			BEQ	FLDONE		; Don't do anything if TX cursor is at 0.
   184 2276 8D 97 22			STA	FLUDCB+8	; Put into Table (Len and Aux)
   185 2279 8D 99 22			STA	FLUDCB+10
   186 227C A9 8F			LDA	#<FLUDCB	; Copy Table to DCB
   187 227E A0 22			LDY	#>FLUDCB
   188 2280 20 E5 23			JSR	DOSIOV		; And call SIOV
   189 2283 20 1C 22			JSR	GDIDX		; Get Unit into X
   190 2286 A9 00			LDA	#$00		; Clear TOFF
   191 2288 9D BF 25			STA	TOFF,X
   192 228B AC 03 03			LDY	DSTATS
   193 228E 60			FLDONE:	RTS			; Done, LDY has DSTATS
   194
   195 228F 71			FLUDCB:	.BYTE      DEVIDN  	; DDEVIC
   196 2290 FF				.BYTE      $FF     	; DUNIT
   197 2291 57				.BYTE      'W'     	; DCOMND
   198 2292 80				.BYTE      DSWRIT     	; DSTATS
   199 2293 4D 26			.WORD      TBUF    	; DBUFL
   200 2295 1F				.BYTE      $1F     	; DTIMLO
   201 2296 00				.BYTE      $00     	; DRESVD
   202 2297 FF				.BYTE      $FF     	; DBYTL
   203 2298 00				.BYTE      $00     	; DBYTH
   204 2299 FF				.BYTE      $FF     	; DAUX1
   205 229A 00				.BYTE      $00     	; DAUX2
   206
   207 					;; Cap RX to 127 bytes (temporary routine)
   208
   209 229B AD EB 02		CAPRX:	LDA	DVSTAT+1	; Get hi-byte
   210 229E D0 05			BNE	CAPADJ		; Adjust if > 256 bytes
   211 22A0 AD EA 02			LDA	DVSTAT		; Get lo-byte
   212 22A3 10 0A			BPL	CAPDON		; Exit if < 127 bytes
   213 22A5 A9 7F		CAPADJ:	LDA	#$7F		; 127 bytes
   214 22A7 8D EA 02			STA	DVSTAT		; into DVSTAT/DVSTAT+1
   215 22AA A9 00			LDA	#$00
   216 22AC 8D EB 02			STA	DVSTAT+1
   217 22AF 60			CAPDON:	RTS			; Done
   218
   219 					;; Close all IOCBs
   220
   221 22B0 A9 04		CLALL:	LDA	#MAXDEV		; Close all 4 N: devices
   222 22B2 8D B6 25			STA	TRIP		; Temporarily use trip
   223 22B5 AD B6 25		CLLP:	LDA	TRIP		; Get
   224 22B8 85 21			STA	ZICDNO		; Store into unit #
   225 22BA 20 3B 24			JSR	CLOSE		; Close Nx:
   226 22BD CE B6 25			DEC	TRIP		; Decrement
   227 22C0 AD B6 25			LDA	TRIP		; Get it
   228 22C3 D0 F0			BNE	CLLP		; Loop until done.
   229 22C5 60				RTS	
   230
   231 					;; Do read from ZIOCB unit
   232
   233 22C6 20 1C 22		READ:	JSR	GDIDX	  	; unit into X
   234 22C9 A5 21			LDA	ZICDNO		; Get Unit #
   235 22CB 8D 5C 23			STA	READCB+1	; Put into Read DCB table
   236 22CE AD CC 25			LDA	BURST		; Are we in burst mode?
   237 22D1 F0 53			BEQ	READNB		; no, do non-bursted read.
   238 22D3 20 20 22		READB:	JSR	POLL		; do status poll to get available bytes
   239 22D6 A5 29			LDA	ZICBLH		; Get hi byte of # of bytes requested
   240 22D8 CD EB 02			CMP	DVSTAT+1	; compare with # of bytes available (H)
   241 22DB 90 11			BCC	READBC		; if < then go ahead and set up the read
   242 22DD A5 28			LDA	ZICBLL		; Get lo byte of # of bytes requested
   243 22DF CD EA 02			CMP	DVSTAT		; compare with # of bytes available (L)
   244 22E2 90 0A			BCC	READBC		; if < then go ahead and set up the read
   245 22E4 AD EA 02		READBJ:	LDA	DVSTAT		; Get bytes available (L)
   246 22E7 85 28			STA	ZICBLL		; Store in requested bytes available (L)
   247 22E9 AD EB 02			LDA	DVSTAT+1	; Get bytes available (H)
   248 22EC 85 29			STA	ZICBLH		; Store in requested bytes available (H)
   249 22EE 38			READBC: SEC			; Set up for subtraction
   250 22EF A5 28			LDA	ZICBLL		; Get requested length
   251 22F1 E9 01			SBC	#$01		; subtract 1
   252 22F3 85 28			STA	ZICBLL		; store back
   253 22F5 90 02			BCC	READBD		; Continue on if done.
   254 22F7 C6 29			DEC	ZICBLH		; Decrement high byte if needed.	
   255 22F9 AD CC 25		READBD:	LDA	BURST		; are we in burst?
   256 22FC F0 0B			BEQ	READBE		; nope continue on
   257 22FE A9 00			LDA	#$00		; Store 0
   258 2300 9D B7 25			STA	RLEN,X		; Into RLEN
   259 2303 8D EB 02			STA	DVSTAT+1
   260 2306 9D BB 25			STA	ROFF,X		; and ROFF, so that next read will get remaining byte.
   261 2309 A5 24		READBE:	LDA	ZICBAL		; Get requested destination buffer (L)
   262 230B 8D 5F 23			STA	READCB+4	; Store into table
   263 230E A5 25			LDA	ZICBAH		; Get requested destination buffer (H)
   264 2310 8D 60 23			STA	READCB+5	; Store into table
   265 2313 A5 28			LDA	ZICBLL		; Get requested length L (which may have been adjusted)
   266 2315 8D 63 23			STA	READCB+8	; Store into table in DBYTL
   267 2318 8D 65 23			STA	READCB+10	; ...and DAUX1
   268 231B A5 29			LDA	ZICBLH		; Get requested length H
   269 231D 8D 64 23			STA	READCB+9	; Store into table in DBYTH
   270 2320 8D 66 23			STA	READCB+11	; ...and DAUX2
   271 2323 4C 46 23			JMP	READ2		; And do the read.	
   272 2326 A9 CD		READNB:	LDA	#<RBUF		; point to non-burst buffer
   273 2328 8D 5F 23			STA	READCB+4	; put in DBUFL
   274 232B A9 25			LDA	#>RBUF		; point to non-burst buffer
   275 232D 8D 60 23			STA	READCB+5	; put in DBUFH
   276 2330 A9 00			LDA	#$00		; Set 0 into
   277 2332 9D BB 25			STA	ROFF,X		; RXD cursor.
   278 2335 8D 64 23			STA	READCB+9	; zero out high byte of DBYTH
   279 2338 8D 66 23			STA	READCB+11	; ...and DAUX2
   280 233B AD B7 25			LDA	RLEN		; Get RLEN (from status)
   281 233E F0 1A			BEQ	RDONE		; If RLEN=0 then abort read.
   282 2340 8D 63 23			STA	READCB+8	; Store in DBYTL
   283 2343 8D 65 23			STA	READCB+10	; Store in DAUX1
   284 2346 A9 5B		READ2:	LDA	#<READCB	; Set up Read DCB
   285 2348 A0 23			LDY	#>READCB	; ...
   286 234A 20 E5 23			JSR	DOSIOV		; Do SIO call
   287 234D AC 03 03			LDY	DSTATS		; Get DSTATS for error
   288 2350 C0 90		READ3:	CPY	#144		; Is it 144?
   289 2352 D0 06			BNE	RDONE		; No, simply return DSTATS in Y
   290 2354 20 20 22			JSR	POLL		; Otherwise, do a poll to get extended error
   291 2357 AC ED 02			LDY	DVSTAT+3	; And return it in Y.
   292 235A 60			RDONE:	RTS			; Done.
   293
   294 235B 71			READCB .BYTE     DEVIDN  	; DDEVIC
   295 235C FF			       .BYTE     $FF     	; DUNIT
   296 235D 52			       .BYTE     'R'     	; DCOMND
   297 235E 40			       .BYTE     DSREAD     	; DSTATS
   298 235F CD 25		       .WORD	 RBUF	 	; DBUF
   299 2361 1F			       .BYTE     $1F     	; DTIMLO
   300 2362 00			       .BYTE     $00     	; DRESVD
   301 2363 FF			       .BYTE     $FF     	; DBYTL
   302 2364 00			       .BYTE     $00     	; DBYTH
   303 2365 FF			       .BYTE     $FF     	; DAUX1
   304 2366 00			       .BYTE     $00     	; DAUX2
   305
   306 					;; set burst = 1
   307 2367 A9 01		SETB:	LDA	#$01		; 1 to
   308 2369 8D CC 25			STA	BURST		; burst mode flag
   309 236C 60				RTS
   310
   311 					;; set burst = 0
   312 236D A9 00		CLRB:	LDA	#$00		; 0 to
   313 236F 8D CC 25			STA	BURST		; burst mode flag
   314 2372 60				RTS
   315 					
   316 				;;; END SUBROUTINES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   317 					
   318 				;;; DEVICE HANDLER TABLE ;;;;;;;;;;;;;;;;;;;;;;;;;
   319
   320 2373 FD 23		DEVHDL:	.WORD	OPEN-1
   321 2375 3A 24			.WORD	CLOSE-1
   322 2377 5E 24			.WORD	GET-1
   323 2379 CE 24			.WORD	PUT-1
   324 237B E6 24			.WORD	STATUS-1
   325 237D 13 25			.WORD	SPECIAL-1
   326 					
   327 				;;; HANDLER RUNAD HERE ;;;;;;;;;;;;;;;;;;;;;;;;;;;
   328 					
   329 237F A5 0C		START:	LDA	DOSINI
   330 2381 8D 02 22			STA	RESET+1
   331 2384 A5 0D			LDA	DOSINI+1
   332 2386 8D 03 22			STA	RESET+2
   333 2389 A9 01			LDA	#<RESET
   334 238B 85 0C			STA	DOSINI
   335 238D A9 22			LDA	#>RESET
   336 238F 85 0D			STA	DOSINI+1
   337 2391 A9 CD			LDA	#<HANDLEREND
   338 2393 8D E7 02			STA	MEMLO
   339 2396 8D 05 22			STA	RESET+4
   340 2399 A9 26			LDA	#>HANDLEREND
   341 239B 8D E8 02			STA	MEMLO+1
   342 239E 8D 0A 22			STA	RESET+9
   343 23A1 20 B0 22			JSR	CLALL		; Close all
   344 					
   345 				;;; Insert Handler entry into HATABS ;;;;;;;;;;;
   346
   347 23A4 A0 00		IHTBS:	LDY	#$00		; Start at beginning of HATABS
   348 23A6 B9 1A 03		IH1:	LDA	HATABS,Y
   349 23A9 F0 0B			BEQ	HFND		; Did we find a blank ($00) entry?
   350 23AB C9 4E			CMP	#'N'		; or did we find our existing 'N' entry?
   351 23AD F0 07			BEQ	HFND		; If so, insert our entry here.
   352 23AF C8				INY			; Otherwise, scoot forward to next entry.
   353 23B0 C8				INY			
   354 23B1 C8				INY
   355 23B2 C0 21			CPY	#11*3		; Are we at the end of the table?
   356 23B4 90 F0			BCC	IH1		; Check again.
   357
   358 					;; We found a slot, insert it in.
   359
   360 23B6 A9 4E		HFND:	LDA	#'N'		; We are the N: device
   361 23B8 99 1A 03			STA	HATABS,Y	; first byte in our entry
   362 23BB A9 73			LDA	#<DEVHDL	; Get address of our handler table
   363 23BD 99 1B 03			STA	HATABS+1,Y	; and put it in Hatabs
   364 23C0 A9 23			LDA	#>DEVHDL
   365 23C2 99 1C 03			STA	HATABS+2,Y
   366 					
   367 					;; And vector in PROCEED.
   368
   369 23C5 A9 15		VPRCD:	LDA	#<INTR		; Get Addr of interrupt handler
   370 23C7 8D 02 02			STA	VPRCED		; Store it in PROCEED vector
   371 23CA A9 22			LDA	#>INTR
   372 23CC 8D 03 02			STA	VPRCED+1
   373 					
   374 					;; We're done, back to DOS.
   375
   376 23CF 60				RTS
   377
   378 				;;; INDICATE SUCCESS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   379
   380 23D0 A0 01		SUCC:	LDY	#$01 		; Indicate success
   381 23D2 60				RTS			; Back to caller.
   382
   383 				;;; CLEAR BUFFERS FOR UNIT X ;;;;;;;;;;;;;;;;;;;;
   384 					
   385 23D3 A9 00		CLRBUF:	LDA	#$00
   386 23D5 9D B7 25			STA	RLEN,X
   387 23D8 9D BF 25			STA	TOFF,X
   388 23DB 9D BB 25			STA	ROFF,X
   389 23DE 9D C4 25			STA	DVS2,X
   390 23E1 9D C8 25			STA	DVS3,X
   391 23E4 60				RTS
   392 					
   393 				;;; COPY TABLE TO DCB AND DO SIO CALL ;;;;;;;;;;;
   394
   395 23E5 8D EE 23		DOSIOV: STA	DODCBL+1	; Set source address
   396 23E8 8C EF 23			STY	DODCBL+2
   397 23EB A0 0C			LDY	#$0C		; 12 bytes
   398 23ED B9 FF FF		DODCBL	LDA	$FFFF,Y		; Changed above.
   399 23F0 99 00 03			STA	DCB,Y		; To DCB table
   400 23F3 88				DEY			; Count down
   401 23F4 10 F7			BPL	DODCBL		; Until done
   402
   403 23F6			SIOVDST:	
   404 23F6 20 59 E4			JSR	SIOV		; Call SIOV
   405 23F9 AC 03 03			LDY	DSTATS		; Get STATUS in Y
   406 23FC 98				TYA			; Copy it into A
   407 23FD 60				RTS			; Done
   408 					
   409 				;;; OPEN ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   410
   411 					;; Fill in the OPEN table
   412 					
   413 23FE 20 1C 22		OPEN:   JSR	GDIDX		; Set IOCB OFFSET TO UNIT #
   414 2401 20 D3 23			JSR	CLRBUF		; Clear Buffers
   415 2404 A5 21			LDA	ZICDNO		; GET Desired unit #
   416 2406 8D 30 24			STA	OPNDCB+1	; Store in open table
   417 2409 A5 24			LDA	ZICBAL		; Get desired buffer LO
   418 240B 8D 33 24			STA	OPNDCB+4	; Store in open table
   419 240E A5 25			LDA	ZICBAH		; Get desired buffer HI
   420 2410 8D 34 24			STA	OPNDCB+5	; Store in open table
   421 2413 A5 2A			LDA	ZICAX1		; Get requested Aux1
   422 2415 8D 39 24			STA	OPNDCB+10	; Store in open table
   423 2418 A5 2B			LDA	ZICAX2		; Get requested Aux2
   424 241A 8D 3A 24			STA	OPNDCB+11	; Store in open table
   425
   426 					;; Do the SIOV call
   427 					
   428 241D A9 2F			LDA	#<OPNDCB
   429 241F A0 24			LDY	#>OPNDCB
   430 2421 20 E5 23			JSR	DOSIOV
   431
   432 					;; Return DSTATS in Y, unless 144, then get ext err.
   433
   434 2424 C0 90			CPY	#144		; Did we get an ERROR- 144?
   435 2426 D0 06			BNE	OPDONE		; Nope, keep DSTATS in Y
   436
   437 					;; We got a 144, get error from STATUS call
   438 2428 20 20 22			JSR	POLL		; Do Status poll
   439 242B AC ED 02			LDY	DVSTAT+3	; Get error code
   440
   441 242E 60			OPDONE:	RTS
   442
   443 					;; OPEN DCB TABLE
   444
   445 242F			OPNDCB:
   446 242F 71				.BYTE      DEVIDN  	; DDEVIC
   447 2430 FF				.BYTE      $FF     	; DUNIT
   448 2431 4F				.BYTE      'O'     	; DCOMND
   449 2432 80				.BYTE      DSWRIT     	; DSTATS
   450 2433 FF				.BYTE      $FF     	; DBUFL
   451 2434 FF				.BYTE      $FF     	; DBUFH
   452 2435 1F				.BYTE      $1F     	; DTIMLO
   453 2436 00				.BYTE      $00     	; DRESVD
   454 2437 00				.BYTE      $00     	; DBYTL
   455 2438 01				.BYTE      $01     	; DBYTH
   456 2439 FF				.BYTE      $FF     	; DAUX1
   457 243A FF				.BYTE      $FF     	; DAUX2
   458
   459 				;;; CLOSE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   460
   461 243B 20 60 22		CLOSE:	JSR	DIPRCD		; Disable PROCEED
   462 243E 20 69 22			JSR	FLUSH		; do PUT flush if needed.
   463 2441 20 D3 23			JSR	CLRBUF		; Clear buffer pointers
   464 2444 A5 21			LDA	ZICDNO		; Unit #
   465 2446 8D 54 24			STA	CLODCB+1	; Put into table
   466 2449 A9 53			LDA	#<CLODCB	; Close DCB table
   467 244B A0 24			LDY	#>CLODCB
   468 244D 20 E5 23			JSR	DOSIOV		; Do SIOV
   469 2450 4C D0 23			JMP	SUCC		; Always return success
   470
   471 2453 71			CLODCB .BYTE	DEVIDN		; DDEVIC
   472 2454 FF			       .BYTE	$FF		; DUNIT
   473 2455 43			       .BYTE	'C'		; DCOMND
   474 2456 00			       .BYTE	$00		; DSTATS
   475 2457 00			       .BYTE	$00		; DBUFL
   476 2458 00			       .BYTE	$00		; DBUFH
   477 2459 1F			       .BYTE	$1F		; DTIMLO
   478 245A 00			       .BYTE	$00		; DRESVD
   479 245B 00			       .BYTE	$00		; DBYTL
   480 245C 00			       .BYTE	$00		; DBYTH
   481 245D 00			       .BYTE	$00		; DAUX1
   482 245E 00			       .BYTE	$00		; DAUX2
   483
   484 				;;; GET ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   485
   486 					;; GET entry point for CIO
   487 					
   488 245F 20 1C 22		GET:	JSR	GDIDX		; Unit into X
   489 2462 20 6D 23			JSR	CLRB		; Clear burst flag.
   490 2465 A5 22			LDA	ZICCOM		; Get command
   491 2467 C9 05			CMP	#5		; GET RECORD?
   492 2469 F0 10			BEQ	GETNOB		; Bypass burst
   493 246B A5 29			LDA	ZICBLH		; high byte of length
   494 246D F0 0C			BEQ	GETNOB		; set burst if > 0
   495 246F A5 28			LDA	ZICBLL		; low byte of length
   496 2471 10 08			BPL	GETNOB		; set burst if > 127
   497 2473 20 67 23			JSR	SETB		; Set burst flag if above conditions fall through.
   498 2476 AD CC 25			LDA	BURST		; Are we now in burst mode?
   499 2479 D0 05			BNE	GETWAI		; Yeah, Wait for some data
   500 247B BD B7 25		GETNOB:	LDA	RLEN,X		; Get current RX len from last STATUS
   501 247E D0 2E			BNE	GETDRN		; If RLEN > 0 then drain.
   502
   503 					;; Otherwise, we wait for something to happen.
   504
   505 2480 20 57 22		GETWAI:	JSR	ENPRCD		; Enable Proceed
   506 2483 AD B6 25			LDA	TRIP		; Did trip change?
   507 2486 F0 F8			BEQ	GETWAI		; Nope, not yet...
   508
   509 					;; Something happened, try to poll for data.
   510
   511 2488 20 20 22			JSR	POLL		; Do Status Poll
   512 248B 20 39 22			JSR	SVSTAT		; Save Status
   513 248E 20 C6 22			JSR	READ		; Do read
   514
   515 					;; If RLEN=0 then determine if error.
   516
   517 2491 AD CC 25			LDA	BURST		; Are we in burst mode?
   518 2494 D0 05			BNE	GETERR		; Yes, check for error.
   519 2496 AD EA 02			LDA	DVSTAT		; Get RLEN Again
   520 2499 D0 13			BNE	GETDRN		; If RLEN > 1, then drain.
   521 249B AC ED 02		GETERR:	LDY	DVSTAT+3	; Get ext err
   522 249E C0 88			CPY	#136		; EOF?
   523 24A0 F0 2A			BEQ	GETDNE		; Yes, return it.
   524 24A2 AC 03 03			LDY	DSTATS		; Else, get DSTATS from status/read.
   525 24A5 C0 90			CPY	#144		; is it 144?
   526 24A7 D0 23			BNE	GETDNE		; Nope, simply return it in Y, done.
   527 24A9 AC ED 02			LDY	DVSTAT+3	; Get Extended error
   528 24AC D0 1E			BNE	GETDNE		; Done.
   529
   530 					;; Drain
   531 					
   532 24AE 20 60 22		GETDRN:	JSR	DIPRCD		; Disable PROCEED
   533 24B1 20 1C 22			JSR	GDIDX		; Get Unit into X again
   534 24B4 DE B7 25			DEC	RLEN,X		; Decrement length
   535 24B7 BC BB 25			LDY	ROFF,X		; Get Current Offset into X
   536 24BA B9 CD 25			LDA	RBUF,Y		; Get next character
   537 24BD FE BB 25			INC	ROFF,X		; Increment cursor
   538 24C0 A8				TAY			; Store in Y for a moment
   539
   540 					;; If RX buffer empty, turn off trip.
   541
   542 24C1 BD B7 25			LDA	RLEN,X		; Get RLEN
   543 24C4 D0 03			BNE	GETDN2		; some left, just go done with success
   544 24C6 8D B6 25			STA	TRIP		; Otherwise store 0 into trip
   545 					
   546 24C9 98			GETDN2:	TYA			; Bring back char into A
   547 24CA A0 01			LDY	#$01		; 
   548 24CC C0 00		GETDNE: CPY	#$00		; Reset flag to negative.
   549 24CE 60				RTS
   550 					
   551 				;;; PUT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   552
   553 24CF 20 1C 22		PUT:	JSR	GDIDX		; Get Unit # into X
   554 24D2 BC BF 25			LDY	TOFF,X		; Get TX cursor
   555 24D5 99 4D 26			STA	TBUF,Y		; Put char into buffer ptd by cursor
   556
   557 24D8 FE BF 25			INC	TOFF,X		; Increment TX cursor
   558
   559 					;; Do a FLUSH if EOL or buffer full
   560
   561 24DB C9 9B			CMP	#EOL		; EOL?
   562 24DD F0 04			BEQ	PFLUSH		; Do flush
   563 24DF C0 7F			CPY	#$7F		; At end of buffer?
   564 24E1 D0 03			BNE	PUTDON		; Nope, done.
   565 24E3 20 69 22		PFLUSH:	JSR	FLUSH		; Do Flush.
   566 24E6 60			PUTDON:	RTS			; We're done.
   567 					
   568 				;;; STATUS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   569
   570 24E7 20 57 22		STATUS:	JSR	ENPRCD		; Enable PROCEED.
   571
   572 					;; Return cached value if we still have data in RX
   573
   574 24EA 20 1C 22			JSR	GDIDX		; Unit into X
   575 24ED BD B7 25			LDA	RLEN,X		; Get RX len
   576 24F0 D0 0E			BNE	STRETC		; Return cached value if RLEN > 0
   577
   578 24F2 AD B6 25			LDA	TRIP		; Get TRIP?
   579 24F5 F0 09			BEQ	STRETC		; No trip? Return cached.
   580
   581 24F7 20 20 22			JSR	POLL		; RLEN = 0, do poll.
   582 24FA 20 39 22			JSR	SVSTAT		; Save DVSTAT values
   583 24FD 20 C6 22			JSR	READ		; Do read.
   584 					
   585 2500 BD B7 25		STRETC:	LDA	RLEN,X		; Get Saved DVSTAT+0 val
   586 2503 8D EA 02			STA	DVSTAT		; Store into DVSTAT
   587 2506 BD C4 25			LDA	DVS2,X		; Get Saved DVSTAT+2 val
   588 2509 8D EC 02			STA	DVSTAT+2	; Store
   589 250C BD C8 25			LDA	DVS3,X		; Get Saved DVSTAT+3 val
   590 250F 8D ED 02			STA	DVSTAT+3
   591 2512 A8				TAY			; copy it into Y for error output.
   592 					
   593 2513 60				RTS			; Done.	
   594 					
   595 				;;; SPECIAL ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   596
   597 2514			SPECIAL:
   598 					
   599 					;; Clear Trip
   600
   601 2514 A9 00			LDA	#$00
   602 2516 8D B6 25			STA	TRIP
   603
   604 					;; Handle Local Commands
   605
   606 2519 A5 22			LDA	ZICCOM
   607 251B C9 0F			CMP	#$0F		; 15 = FLUSH
   608 251D D0 08			BNE	SPQ		; No. Handle protocol commands
   609 251F 20 69 22			JSR	FLUSH		; Yes. Do flush.
   610 2522 A0 01			LDY	#$01		; Flush always successful
   611 2524 4C A9 25			JMP	SPCDNE		; We're done.
   612
   613 					;; Handle Protocol commands, do INQDS Query
   614
   615 2527 A9 FF		SPQ:	LDA	#$FF		; Set INQDS
   616 2529 8D AC 25			STA	SPEDCB+2		; To DCOMND
   617 252C A5 21			LDA	ZICDNO		; Get Unit #
   618 252E 8D AB 25			STA	SPEDCB+1	; Store in table
   619 2531 A5 22			LDA	ZICCOM		; Get Command
   620 2533 8D B4 25			STA	SPEDCB+10	; Put in AUX1 for query
   621 2536 A9 01			LDA	#$01		; 1 byte
   622 2538 8D B2 25			STA	SPEDCB+8	;
   623 253B A9 00			LDA	#$00		;
   624 253D 8D B3 25			STA	SPEDCB+9	;
   625 2540 A9 C3			LDA	#<INQDS		; Stora INQDS address
   626 2542 8D AE 25			STA	SPEDCB+4	; ...
   627 2545 A9 25			LDA	#>INQDS		; ...
   628 2547 8D AF 25			STA	SPEDCB+5
   629 254A A9 40			LDA	#$40		; <-Atari
   630 254C 8D AD 25			STA	SPEDCB+3
   631 254F A9 AA			LDA	#<SPEDCB	; Set up SPECIAL DCB TABLE
   632 2551 A0 25			LDY	#>SPEDCB	;
   633 2553 20 E5 23			JSR	DOSIOV		; Do Query
   634 2556 AC 03 03			LDY	DSTATS		; Get DSTATS
   635 2559 30 4E			BMI	SPCDNE		; SIO error, return in Y. There is no ext err.
   636
   637 					;; We got a query, if it's $FF, return unimplemented.
   638 255B AD C3 25			LDA	INQDS		; Get the Returned DSTATS value from inquiry
   639 255E C9 FF			CMP	#$FF		; Is it $FF ?
   640 2560 D0 05			BNE	SPDO		; Nope, let's do it.
   641 2562 A0 92			LDY	#146		; ERROR- 146  Unimplemented Command
   642 2564 4C A9 25			JMP	SPCDNE		; Done.
   643
   644 					;; Do the Special, get all IOCB params, push onto stack
   645 					
   646 2567 A5 21		SPDO:	LDA	ZICDNO		; Unit #
   647 2569 8D AB 25			STA	SPEDCB+1
   648 256C A5 22			LDA	ZICCOM		; Command
   649 256E 8D AC 25			STA	SPEDCB+2
   650 2571 AD C3 25			LDA	INQDS		; Result of Inquiry
   651 2574 8D AD 25			STA	SPEDCB+3
   652 2577 A5 24			LDA	ZICBAL		; Ptr to passed in devicespec
   653 2579 8D AE 25			STA	SPEDCB+4
   654 257C A5 25			LDA	ZICBAH		; 
   655 257E 8D AF 25			STA	SPEDCB+5
   656 2581 A9 00			LDA #$00
   657 2583 8D B2 25			STA SPEDCB+8
   658 2586 A9 01			LDA #$01
   659 2588 8D B3 25			STA SPEDCB+9
   660 258B A5 2A			LDA	ZICAX1		; Aux1
   661 258D 8D B4 25			STA	SPEDCB+10
   662 2590 A5 2B			LDA	ZICAX2		; Aux2
   663 2592 8D B5 25			STA	SPEDCB+11
   664 2595 A9 AA			LDA	#<SPEDCB
   665 2597 A0 25			LDY	#>SPEDCB
   666 2599 20 E5 23			JSR	DOSIOV
   667
   668 					;; Get error and return extended if needed.
   669
   670 259C AC 03 03			LDY	DSTATS		; Get DSTATS
   671 259F C0 90			CPY	#144		; Is it 144?
   672 25A1 D0 06			BNE	SPCDNE		; Nope, just return it.
   673
   674 25A3 20 20 22			JSR	POLL		; Get status, for error
   675 25A6 AC ED 02			LDY	DVSTAT+3	; Get extended error.
   676 					
   677 25A9 60			SPCDNE:	RTS
   678
   679 25AA 71			SPEDCB .BYTE      DEVIDN  ; DDEVIC
   680 25AB FF			       .BYTE      $FF     ; DUNIT
   681 25AC FF			       .BYTE      $FF     ; DCOMND ; inq
   682 25AD 40			       .BYTE      DSREAD     ; DSTATS
   683 25AE C3 25		       .WORD      INQDS    ; DBUFL
   684 25B0 1F			       .BYTE      $1F     ; DTIMLO
   685 25B1 00			       .BYTE      $00     ; DRESVD
   686 25B2 01			       .BYTE      $01     ; DBYTL
   687 25B3 00			       .BYTE      $00     ; DBYTH
   688 25B4 FF			       .BYTE      $FF     ; DAUX1
   689 25B5 FF			       .BYTE      $FF     ; DAUX2	
   690 					
   691 					;; End of Handler
   692
   693 				;;; VARIABLES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   694
   695 = 25B6			TRIP	.ds	1		; Interrupt Tripped?
   696 = 25B7			RLEN	.ds	MAXDEV		; RXD Len
   697 = 25BB			ROFF	.ds	MAXDEV		; RXD offset cursor
   698 = 25BF			TOFF	.ds	MAXDEV		; TXD offset cursor
   699 = 25C3			INQDS	.ds	1		; DSTATS to return in inquiry
   700 = 25C4			DVS2	.ds	MAXDEV		; DVSTAT+2 SAVE
   701 = 25C8			DVS3	.ds	MAXDEV		; DVSTAT+3 SAVE
   702 = 25CC			BURST	.ds	1		; Is this operation in burst mode?
   703 					
   704 = 25CD			RBUF	.ds	128		; RXD buffer
   705 = 264D			TBUF	.ds	128		; TXD buffer
   706 					
   707 = 26CD			HANDLEREND	= *
   708
   709 02E0-02E1> 7F 23			RUN	START
   710 					END
